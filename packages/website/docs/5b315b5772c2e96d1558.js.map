{"version":3,"file":"5b315b5772c2e96d1558.js","mappings":"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","sources":["webpack://website/../src/hooks/useForceUpdate/index.js","webpack://website/../src/hooks/useSubscription/index.js","webpack://website/../src/components/common/Rows/index.js","webpack://website/../src/constants/events.js","webpack://website/../src/utils/cx/index.js","webpack://website/../src/components/common/Container/HeightProvider/index.js","webpack://website/../src/utils/dimensionsObserver/index.js","webpack://website/../src/models/ListBase/index.js","webpack://website/../src/models/PubSub/index.js","webpack://website/../src/utils/throttle/index.js","webpack://website/../src/models/VariableSizeList/index.js","webpack://website/../src/models/FixedSizeList/index.js","webpack://website/../src/components/common/Container/index.js","webpack://website/../src/components/List/index.js","webpack://website/../src/components/common/ExtraHeight/index.js","webpack://website/../src/components/Table/Colgroup/index.js","webpack://website/../src/components/Table/index.js","webpack://website/../src/components/Table/renderers.js"],"sourcesContent":["import { useReducer } from \"react\";\n\nconst increment = x => x + 1;\n\nconst useForceUpdate = () => useReducer( increment, 0 )[ 1 ];\n\nexport default useForceUpdate;","import { useRef, useEffect } from \"react\";\nimport useForceUpdate from \"../useForceUpdate\";\n\nconst useSubscription = ( model, callBack, events ) => {\n    \n    const prevRenderRef = useRef( null );\n    const forceUpdate = useForceUpdate();\n    \n    useEffect(() => {\n        model.on( forceUpdate, ...events );\n        return () => model.off( forceUpdate, ...events );\n    }, events );\n\n    if( model._inBatch ){\n        /*\n            Somebody tried to rerender, while we were in batch.\n            On batch finish component definitely must be rerendered.\n        */\n        model.queue( forceUpdate );\n    }\n    else{\n        prevRenderRef.current = callBack( model );\n    }\n    \n    return prevRenderRef.current;\n}\n\nexport default useSubscription;","import useSubscription from \"src/hooks/useSubscription\";\r\nimport { START_INDEX, END_INDEX } from \"src/constants/events\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst Events = [ START_INDEX, END_INDEX ];\r\n\r\nconst spacerKey = Date.now().toString(36);\r\n\r\nconst Rows = ({ model, children, Spacer = \"div\", ...rest }) => useSubscription(\r\n    model, \r\n    ({ startIndex, endIndex, virtualTopOffset, setSpacerNode }) => {\r\n        \r\n        const result = [\r\n            <Spacer\r\n                key={spacerKey}\r\n                className={css.spacer}\r\n                aria-hidden=\"true\"\r\n                style={{ height: virtualTopOffset}}\r\n                ref={setSpacerNode}\r\n            />\r\n        ];    \r\n        \r\n        for( let i = startIndex; i < endIndex; i++ ){\r\n            result.push(children( i, rest ));\r\n        }\r\n\r\n        return result;\r\n    },\r\n    Events\r\n);\r\n\r\nexport default Rows;","export const START_INDEX                    = 0;\nexport const END_INDEX                      = 1;\nexport const ROWS_QUANTITY                  = 2;\nexport const WIDGET_SCROLL_HEIGHT           = 3;\nexport const WIDGET_EXTRA_STICKY_HEIGHT     = 4;\nexport const WIDGET_HEIGHT                  = 5;\nexport const WIDGET_WIDTH                   = 6;\n\nexport const EVENTS_ARRAY_LENGTH            = 7;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\r\n\r\nexport default cx;","import useSubscription from \"src/hooks/useSubscription\";\nimport { WIDGET_SCROLL_HEIGHT, WIDGET_EXTRA_STICKY_HEIGHT } from \"src/constants/events\";\nimport css from \"./style.module.scss\";\n\nconst Events = [ WIDGET_SCROLL_HEIGHT, WIDGET_EXTRA_STICKY_HEIGHT ];\n\nconst HeightProvider = ({ model }) => useSubscription( model, API => (\n    <div\n        aria-hidden=\"true\"\n        className={css.wrapper}\n        style={{ height: API.widgetScrollHeight + API.extraStickyHeight }}\n    />\n), Events );\n\nexport default HeightProvider;","const callBacks = new Map();\n\nconst R = new ResizeObserver( entries => {\n    for( const { target } of entries ){\n        const cb = callBacks.get( target );\n        cb && cb( target );\n    }\n});\n\nexport const observe = ( el, callBack ) => {\n    callBacks.set( el, callBack );\n    R.observe( el );\n}\n\nexport const unobserve = el => callBacks.delete( el ) && R.unobserve( el );","import PubSub from \"../PubSub\";\nimport throttle from \"src/utils/throttle\";\nimport { observe, unobserve } from \"src/utils/dimensionsObserver\";\n\nimport {\n    START_INDEX,\n    END_INDEX,\n    ROWS_QUANTITY,\n    WIDGET_SCROLL_HEIGHT,\n    WIDGET_EXTRA_STICKY_HEIGHT,\n    WIDGET_HEIGHT,\n    WIDGET_WIDTH\n} from \"src/constants/events\";\n\nclass ListBase extends PubSub {\n\n    /* Provided from renderer */\n    _scrollTop = 0;\n\n    rowsQuantity = 0;\n\n    /* must be >= 1 */\n    _overscanRowsCount = 2;\n\n    _widgetHeight = 0;\n    _widgetWidth = 0;\n\n    /* sticky elements ( for example table header/footer ) must influence ONLY on widgetScrollHeight */\n    extraStickyHeight = 0;\n\n    _estimatedRowHeight = 0;\n\n    _spacerNode = null;\n    _scrollContainerNode = null;\n\n    _updateWidgetDimensions = ({ offsetHeight, offsetWidth }) => {\n\n        this.startBatch();\n\n        if( offsetHeight !== this._widgetHeight ){\n            this._widgetHeight = offsetHeight;\n            this._emit( WIDGET_HEIGHT );\n        }\n\n        if( offsetWidth !== this._widgetWidth ){\n            this._widgetWidth = offsetWidth;\n            this._emit( WIDGET_WIDTH );\n        }\n\n        this.endBatch();\n    }\n\n    _unobserveCurrentScrollContainerNode(){\n        if( this._scrollContainerNode ){\n            unobserve( this._scrollContainerNode );\n        }\n    }\n\n    /* will ne used as callback, so => */\n    setScrollContainerNode = node => {\n        this._unobserveCurrentScrollContainerNode();\n        this._scrollContainerNode = node || null;\n        if( node ){\n            observe( node, this._updateWidgetDimensions );\n        }\n    }\n\n    /* will ne used as callback, so => */\n    setSpacerNode = node => {\n        this._spacerNode = node;\n    }\n\n    setScrollTop( v ){\n        if( v !== this._scrollTop ){\n            this._scrollTop = v;\n            this._updateVisibleRange();\n        }\n    }\n\n    updateExtraStickyHeight( delta ){\n        if( delta ){\n            this.extraStickyHeight += delta;\n            this._emit( WIDGET_EXTRA_STICKY_HEIGHT );\n        }\n    }\n\n    _updateEndIndex(){\n\n        const endIndex = Math.min( this.getIndex( this._scrollTop + this._widgetHeight ) + this._overscanRowsCount, this.rowsQuantity );\n\n        if( endIndex !== this.endIndex ){\n            this.endIndex = endIndex;\n            this._emit( END_INDEX );\n        }\n    }\n\n    _updateVisibleRange(){\n\n        this.startBatch();\n        \n        const startIndex = Math.max( 0, this.getIndex( this._scrollTop ) - this._overscanRowsCount );\n\n        if( startIndex !== this.startIndex ){\n            this.startIndex = startIndex;\n            this.virtualTopOffset = this.getOffset( startIndex );\n            this._emit( START_INDEX );\n        }\n\n        this._updateEndIndex()\n        this.endBatch();\n    }\n\n\n    /* must be called when row height/heights change */\n    _remeasure(){\n        this.startBatch();\n        this._updateWidgetScrollHeight();\n        this._updateVisibleRange();\n        this.endBatch();\n    }\n\n    _measureRowsThrottled = throttle( this._measureRows, 200, this );\n\n    constructor(){\n        super()\n\n        this\n            .on( this._measureRowsThrottled, ROWS_QUANTITY, WIDGET_HEIGHT, WIDGET_WIDTH )\n            .on( this._updateWidgetScrollHeight, ROWS_QUANTITY )\n            .on( this._updateEndIndex, ROWS_QUANTITY, WIDGET_HEIGHT );\n    }\n\n    destructor(){\n        this._unobserveCurrentScrollContainerNode();\n        this._measureRowsThrottled.cancel();\n        super.destructor();\n    }\n\n    scrollToRow( rowIndex ){\n        if( this._scrollContainerNode ){\n            this._scrollContainerNode.scrollTop = this.getOffset( rowIndex );\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.error( \"scrollContainerNode is not set\" );\n        }\n    }\n\n    _updateWidgetScrollHeight(){\n        const v = this.getOffset( this.rowsQuantity );\n        if( v !== this.widgetScrollHeight ){\n            this.widgetScrollHeight = v;\n            this._emit( WIDGET_SCROLL_HEIGHT );\n        }\n    }\n\n    setParams( estimatedRowHeight, overscanRowsCount, rowsQuantity ){\n\n        this._estimatedRowHeight = estimatedRowHeight;\n\n        this.startBatch();\n\n        if( overscanRowsCount !== this._overscanRowsCount ){\n            this._overscanRowsCount = overscanRowsCount;\n            this.queue( this._updateVisibleRange );\n        }\n\n        if( rowsQuantity !== this.rowsQuantity ){\n            this.rowsQuantity = rowsQuantity;\n            this._emit( ROWS_QUANTITY );\n        }\n\n        this.endBatch();\n    }\n\n    /* Calculated inside model */\n    startIndex = 0;\n    endIndex = 0;\n    virtualTopOffset = 0;\n    widgetScrollHeight = 0;\n}\n\nexport default ListBase;","import { EVENTS_ARRAY_LENGTH } from \"src/constants/events\";\n\nclass PubSub {\n\n    /* All callbacks are known in advance, so we can allocate in construcror */\n    _E = Array.from({ length: EVENTS_ARRAY_LENGTH }, () => []);\n\n    /* query of callbacks, that should run after batch end */\n    _Q = new Set();\n\n    /* depth of batch */\n    _inBatch = 0;\n\n    _on( callBack, events, shouldPrepend ){\n        for( const evt of events ){\n            this._E[ evt ].splice( shouldPrepend ? 0 : 0x7fffffff, 0, callBack );\n        }\n        return this;\n    }\n\n    on( callBack, ...events ){\n        return this._on( callBack, events, false );\n    }\n\n    prependListener( callBack, ...events ){\n        return this._on( callBack, events, true );\n    }\n\n    destructor(){\n        for( const events of this._E ){\n            events.splice( 0 );\n        }\n        this._Q.clear();\n    }\n\n    off( callBack, ...events ){\n        for( const evt of events ){\n            this._E[ evt ].splice( this._E[ evt ].indexOf( callBack ) >>> 0, 1 );\n        }\n        return this;\n    }\n\n    queue( cb ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( !this._inBatch ){\n                console.error( \"trying to add event to batch queue, while _inBatch is 0\" );\n            }\n        }\n        this._Q.add( cb );\n    }\n\n    _emit( evt ){\n        if( this._inBatch ){\n            for( const cb of this._E[ evt ] ){\n                this._Q.add( cb );\n            }\n        }\n        else{\n            for( const cb of this._E[ evt ] ){\n                cb.call( this );\n            }\n        }\n    }\n\n    /* inspired by mobx */\n\n    startBatch(){\n        this._inBatch++;\n    }\n\n    endBatch(){\n        if( --this._inBatch === 0 ){\n            for( const cb of this._Q ){\n                cb.call( this );\n            }\n            this._Q.clear();\n        }\n    }\n}\n\nexport default PubSub;","const throttle = ( fn, ms, ctx ) => {\n    let timer = 0;\n\n    const cancel = () => {\n        clearTimeout( timer );\n        timer = 0;\n    }\n\n    const invoke = () => {\n        timer = 0;\n        fn.call( ctx );\n    }\n\n    const throttled = () => {\n        if( timer === 0 ){\n            timer = setTimeout( invoke, ms );\n        }\n    }\n\n    throttled.cancel = cancel;\n\n    return throttled;\n}\n\nexport default throttle;","import ListBase from \"../ListBase\";\n\nimport {\n    ROWS_QUANTITY,\n    START_INDEX,\n    END_INDEX,\n} from \"src/constants/events\";\n\nclass VariableSizeList extends ListBase {\n    \n    _rowHeights = [];\n    _fTree = [];\n\n    /*\n        most significant bit of this.rowsQuantity;\n        caching it to avoid Math.clz32 calculations on every getIndex call\n    */\n    _msb = 0;\n    \n    constructor(){\n        super();\n\n        this\n            /* must be done before events, attached in ListBase */\n            .prependListener( this._grow, ROWS_QUANTITY )\n            .on( this._measureRowsThrottled, START_INDEX, END_INDEX );            \n    }\n\n    _grow(){\n\n        const { rowsQuantity } = this;\n\n        if( rowsQuantity < 0 || rowsQuantity > 0x7fffffff ){\n            throw new Error( `Wrong rowsQuantity: ${rowsQuantity}. Must be 0...2_147_483_647.` )\n        }\n\n        this._msb = rowsQuantity && 1 << 31 - Math.clz32( rowsQuantity );\n\n        const curRowHeighsLength = this._rowHeights.length;\n\n        if( rowsQuantity > curRowHeighsLength ){\n\n            const oldRowHeights = this._rowHeights;\n            \n            this._rowHeights = new Uint32Array( rowsQuantity );\n            this._fTree = new Uint32Array( rowsQuantity + 1 );\n\n            this._rowHeights.set( oldRowHeights );\n            this._rowHeights.fill( this._estimatedRowHeight, curRowHeighsLength );\n\n\n            /* \n                Creating fenwick tree from an array in linear time;\n                It is much more efficient, than calling updateRowHeight N times.\n            */\n\n            this._fTree.set( this._rowHeights, 1 );\n\n            for( let i = 1, j; i <= rowsQuantity; i++ ){\n                j = i + ( i & -i );\n                if( j <= rowsQuantity ){\n                    this._fTree[ j ] += this._fTree[ i ];\n                }\n            }\n\n            this._remeasure();\n        }        \n    }\n\n    getIndex( offset ){\n        let index = 0;\n        \n        for( let bitMask = this._msb, tempIndex; bitMask !== 0; bitMask >>= 1 ){\n            tempIndex = index + bitMask;\n            if( tempIndex > this.rowsQuantity ){\n                continue;\n            }\n            if( offset === this._fTree[ tempIndex ] ){\n                return tempIndex;\n            }\n            if( offset > this._fTree[ tempIndex ] ) {\n                offset -= this._fTree[ tempIndex ];\n                index = tempIndex;\n            }\n        }\n\n        return index;\n    }\n\n    getOffset( index ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( index > this.rowsQuantity ){\n                throw new Error( \"index must not be > rowsQuantity\" );\n            }\n        }\n\n        let result = 0;\n\n        for ( ; index > 0; index -= index & -index ){\n            result += this._fTree[ index ];\n        }\n\n        return result;\n    }\n\n    /* i starts from 1 here; */\n    _updateRowHeight( i, delta, limitTreeLiftingIndex ){\n        for ( ; i < limitTreeLiftingIndex; i += i & -i ){\n            this._fTree[ i ] += delta;\n        }\n    }\n\n    _measureRows(){\n        let child = this._spacerNode?.nextElementSibling;\n\n        if( child ){\n\n            let index = this.startIndex,\n                diff,\n                buff = 0;\n            \n            /* We can batch-update fenwick tree, if we know, that all indexes are updated in +1 - order. */\n            const lim = Math.min( this._fTree.length, 1 << 32 - Math.clz32( this.endIndex - 1 ) );\n\n\n            do {\n     \n                diff = child.offsetHeight - this._rowHeights[ index ];\n\n                if( diff ){\n                    this._rowHeights[ index ] += diff;\n                    buff += diff;\n                    this._updateRowHeight( index + 1, diff, lim );                  \n                }                \n            }\n            while( ++index < this.endIndex && ( child = child.nextElementSibling ) );\n\n            if( buff ){\n                this._updateRowHeight( lim, buff, this._fTree.length );\n                this._remeasure();\n            }\n        }\n    }\n}\n\nexport default VariableSizeList;","import ListBase from \"../ListBase\";\n\nclass FixedSizeList extends ListBase {\n\n    _rowHeight = 0;\n\n    _setRowHeight( v ){\n        if( v !== this._rowHeight ){\n            this._rowHeight = v;\n            this._remeasure();\n        }\n    }\n\n    getIndex( offset ){\n        /* rounding via bitwise hacks like |0 may not work here, because number may be > max(int32) */\n        return this._rowHeight && Math.trunc( offset / this._rowHeight );\n    }\n\n    getOffset( index ){\n        return index * this._rowHeight;\n    }\n\n    _measureRows(){\n        if( this.rowsQuantity ){\n            const tgtEl = this._spacerNode?.nextElementSibling;\n            \n            if( tgtEl ){\n                this._setRowHeight( tgtEl.offsetHeight );\n            }   \n        }\n    }    \n}\n\nexport default FixedSizeList;","import { useState, useEffect, useImperativeHandle } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport cx from \"src/utils/cx\";\r\nimport {\r\n    END_INDEX,\r\n    ROWS_QUANTITY\r\n} from \"src/constants/events\";\r\nimport HeightProvider from \"./HeightProvider\";\r\nimport VariableHeightsModel from \"src/models/VariableSizeList\";\r\nimport FixedHeightsModel from \"src/models/FixedSizeList\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst EMPTY_ARRAY = [];\r\n\r\nconst Container = ({\r\n    rowsQuantity,\r\n    children,\r\n    as: Component = \"div\",\r\n    fixed = false,\r\n    estimatedRowHeight = 20,\r\n    overscanRowsCount = 2,\r\n    dataRef,\r\n    onRangeEndMove,\r\n    className,\r\n    ...props\r\n}) => {\r\n    \r\n    const [ model ] = useState(() => new ( fixed ? FixedHeightsModel : VariableHeightsModel ));\r\n\r\n    useImperativeHandle( dataRef, () => model, EMPTY_ARRAY);\r\n\r\n    model.startBatch();\r\n    model.setParams( estimatedRowHeight, overscanRowsCount, rowsQuantity );\r\n\r\n    useEffect(() => {\r\n        model.endBatch();\r\n    });\r\n\r\n    useEffect(() => {\r\n        if( onRangeEndMove ){\r\n            const evt = () => onRangeEndMove( model );\r\n            evt();\r\n            model.on( evt, ROWS_QUANTITY, END_INDEX );\r\n            return () => model.off( evt, ROWS_QUANTITY, END_INDEX );\r\n        }\r\n    }, [ onRangeEndMove ]);\r\n\r\n    useEffect(() => () => model.destructor(), EMPTY_ARRAY);\r\n\r\n    if( process.env.NODE_ENV !== \"production\" ){\r\n        const AssumedConstructor = fixed ? FixedHeightsModel : VariableHeightsModel;\r\n        if( !( model instanceof AssumedConstructor ) ){\r\n            console.warn( `\r\n                'fixed' prop is taken into account ONLY during initial component mount.\r\n                All future changes are ignored. You must decide once.`\r\n            );\r\n        }\r\n    }\r\n    \r\n    /*\r\n        tabIndex=\"0\" is for proper keyboard nav\r\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n    */\r\n    return (\r\n        <Component\r\n            {...props}\r\n            tabIndex=\"0\"\r\n            className={cx(css.wrapper,className)}\r\n            ref={model.setScrollContainerNode}\r\n            onScroll={e => model.setScrollTop( e.target.scrollTop )}\r\n        >\r\n            <HeightProvider model={model} />\r\n            {children( model )}\r\n        </Component>\r\n    );\r\n};\r\n\r\nContainer.propTypes = {\r\n    rowsQuantity: PropTypes.number.isRequired,\r\n    Container: PropTypes.elementType,\r\n    className: PropTypes.string,\r\n    fixed: PropTypes.bool,\r\n    overscanRowsCount: PropTypes.number,\r\n    estimatedRowHeight: PropTypes.number,\r\n    onRangeEndMove: PropTypes.func,\r\n}\r\n\r\nexport default Container;","import { memo } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nimport Rows from \"../common/Rows\";\r\nimport Container from \"../common/Container\";\r\n\r\nconst List = ({ children, ...props }) => (\r\n    <Container {...props}>\r\n        {model => <Rows model={model}>{children}</Rows>}\r\n    </Container>\r\n);\r\n\r\nList.propTypes = {\r\n    /**\r\n     * @param {number} rowIndex\r\n     * @returns {any} one row element child. Fragments are not supported.\r\n     */\r\n    children: PropTypes.func.isRequired\r\n}\r\n\r\nexport default memo( List );","import { useState, cloneElement, useEffect } from \"react\";\nimport { observe, unobserve } from \"src/utils/dimensionsObserver\";\n\nconst ExtraHeight = ({ model, children }) => {\n\n    const [ el, ref ] = useState();\n\n    useEffect(() => {\n        if( el && model ){\n            let prevHeight = 0;\n\n            observe( el, ({ offsetHeight }) => {\n                model.updateExtraStickyHeight( offsetHeight - prevHeight );\n                prevHeight = offsetHeight;\n            });\n    \n            return () => {\n                unobserve( el );\n                model.updateExtraStickyHeight( -prevHeight );\n            }\n        }\n    }, [ el, model ]);\n\n    return cloneElement( children, { ref });\n}\n\nexport default ExtraHeight;","import { memo } from \"react\";\r\n\r\nconst mapper = ({ dataKey, background, border, width }) => (\r\n    <col\r\n        key={dataKey}\r\n        style={{\r\n            width,\r\n            background,\r\n            border\r\n        }}\r\n    />\r\n);\r\n\r\nconst Colgroup = ({ columns }) => (\r\n    <colgroup>\r\n        {columns.map( mapper )}\r\n    </colgroup>\r\n);\r\n\r\nexport default memo( Colgroup );","import { memo } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport cx from \"src/utils/cx\";\r\n\r\nimport Rows from \"../common/Rows\";\r\nimport Container from \"../common/Container\";\r\nimport ExtraHeight from \"../common/ExtraHeight\";\r\n\r\nimport Colgroup from \"./Colgroup\";\r\n\r\nimport {\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    Cell\r\n} from \"./renderers\";\r\n\r\nimport \"./style.scss\";\r\nimport css from \"./style.module.scss\";\r\n\r\n/*\r\n    Todo:\r\n        * think about border-collapse offsetHeight issue ( maybe throw border-collapse )\r\n*/\r\n\r\nconst Table = ({\r\n    columns,\r\n    getRowData,\r\n    getRowProps,\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    renderTfootContent,\r\n    Cell,\r\n    headless,\r\n    className,\r\n    ...props\r\n}) => (\r\n    <Container className={cx(\"afvscr-table\",className)} {...props}>\r\n        {model => (\r\n            <table className={css.bodyTable}>\r\n                <Colgroup columns={columns} />\r\n                {headless ? null : (\r\n                    <ExtraHeight model={model}>\r\n                        <thead>\r\n                            <tr>\r\n                                {renderHeaderCells(columns)}\r\n                            </tr>\r\n                        </thead>\r\n                    </ExtraHeight>\r\n                )}\r\n                <tbody>\r\n                    <Rows\r\n                        model={model}\r\n                        Spacer=\"tr\"\r\n                        columns={columns}\r\n                        getRowData={getRowData}\r\n                        getRowProps={getRowProps}\r\n                        Row={Row}\r\n                        Cell={Cell}\r\n                    >\r\n                        {renderRow}\r\n                    </Rows>\r\n                </tbody>\r\n                {renderTfootContent ? (\r\n                    <ExtraHeight model={model}>\r\n                        <tfoot>\r\n                            {renderTfootContent( columns )}\r\n                        </tfoot>\r\n                    </ExtraHeight>\r\n                ) : null}\r\n            </table>\r\n        )}\r\n    </Container>\r\n);\r\n\r\nTable.propTypes = {\r\n    className: PropTypes.string,\r\n    columns: PropTypes.arrayOf(\r\n        PropTypes.oneOfType([\r\n            PropTypes.string,\r\n                PropTypes.shape({\r\n                // unique key for column\r\n                dataKey: PropTypes.string.isRequired,\r\n\r\n                // for details see CellComponent implementation\r\n                format: PropTypes.func,\r\n                render: PropTypes.func,\r\n                formatTotal: PropTypes.func,\r\n                totals: PropTypes.string,\r\n\r\n                // column props, affecting colgroup > col tags\r\n                background: PropTypes.string,\r\n                border: PropTypes.string,\r\n                width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                \r\n                // works pretty shitty in col tag\r\n                minWidth: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                CellComponent: PropTypes.elementType,\r\n                getCellExtraProps: PropTypes.func\r\n            })\r\n        ])\r\n    ).isRequired,\r\n\r\n    getRowData: PropTypes.func.isRequired,\r\n    getRowProps: PropTypes.func,\r\n    renderTfootContent: PropTypes.func,\r\n    renderHeaderCells: PropTypes.func,\r\n    Row: PropTypes.elementType,\r\n    Cell: PropTypes.elementType,\r\n\r\n    headless: PropTypes.bool,\r\n};\r\n\r\n\r\nTable.defaultProps = {\r\n    headless: false,\r\n\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    Cell\r\n};\r\n\r\nexport default memo( Table );","/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nexport const Row = ({ index, columns, getRowData, getRowProps, Cell }) => {\n\n    const rowData = getRowData( index );\n\n    return (\n        <tr {...(getRowProps&&getRowProps(rowData,index))}>\n            {rowData ? columns.map( column => {\n                const FinalCell = column.Cell || Cell;\n                return (\n                    <td key={column.dataKey}>\n                        <FinalCell rowData={rowData} column={column} />\n                    </td>\n                );\n            }) : (\n                <td colSpan={columns.length}>\n                    {DEFAULT_EMPTY_CELL_CONTENT}\n                </td>\n            )}\n        </tr>\n    );\n}\n\nexport const renderRow = ( index, RowProps ) => <RowProps.Row key={index} index={index} {...RowProps} />\n\nexport const renderHeaderCells = columns => columns.map( column => (\n    <th key={column.dataKey} style={{ minWidth: column.minWidth }}>\n        {column.label}\n    </th>\n));\n\nexport const Cell = ({ rowData, column }) => {\n    const { render, dataKey, format } = column;\n\n    const cellData = rowData[ dataKey ];\n    \n    if( cellData === undefined ){\n        return DEFAULT_EMPTY_CELL_CONTENT;\n    }\n\n    if( render ){\n        return render( cellData, rowData );\n    }\n\n    if( format ){\n        return format( cellData );\n    }\n\n    return cellData;\n}"],"names":["increment","x","model","callBack","events","prevRenderRef","useRef","forceUpdate","useReducer","useEffect","on","off","_inBatch","queue","current","Events","spacerKey","Date","now","toString","Rows","_ref","children","Spacer","rest","useSubscription","startIndex","endIndex","virtualTopOffset","setSpacerNode","result","_jsx","className","style","height","ref","i","push","cx","baseClass","extraClass","HeightProvider","API","widgetScrollHeight","extraStickyHeight","callBacks","Map","R","ResizeObserver","entries","target","cb","get","observe","el","set","unobserve","delete","ListBase","_E","Array","from","length","_Q","Set","_on","shouldPrepend","evt","splice","this","prependListener","destructor","clear","indexOf","add","_emit","call","startBatch","endBatch","_unobserveCurrentScrollContainerNode","_scrollContainerNode","setScrollTop","v","_scrollTop","_updateVisibleRange","updateExtraStickyHeight","delta","_updateEndIndex","Math","min","getIndex","_widgetHeight","_overscanRowsCount","rowsQuantity","max","getOffset","_remeasure","_updateWidgetScrollHeight","constructor","_widgetWidth","_estimatedRowHeight","_spacerNode","_updateWidgetDimensions","offsetHeight","offsetWidth","setScrollContainerNode","node","_measureRowsThrottled","fn","ms","ctx","timer","invoke","throttled","setTimeout","cancel","clearTimeout","throttle","_measureRows","scrollToRow","rowIndex","scrollTop","setParams","estimatedRowHeight","overscanRowsCount","_rowHeights","_fTree","_msb","_grow","Error","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","fill","j","offset","index","tempIndex","bitMask","_updateRowHeight","limitTreeLiftingIndex","child","nextElementSibling","diff","buff","lim","_rowHeight","_setRowHeight","trunc","tgtEl","EMPTY_ARRAY","Container","as","Component","fixed","dataRef","onRangeEndMove","props","useState","FixedHeightsModel","VariableHeightsModel","useImperativeHandle","_jsxs","tabIndex","onScroll","e","List","memo","ExtraHeight","prevHeight","cloneElement","mapper","dataKey","background","border","width","columns","map","Table","getRowData","getRowProps","renderRow","Row","renderHeaderCells","renderTfootContent","Cell","headless","Colgroup","defaultProps","RowProps","rowData","column","FinalCell","colSpan","minWidth","label","render","format","cellData"],"sourceRoot":""}