{"version":3,"file":"a1ef0576ee46b24f19cf.js","mappings":";2NAAA,MCAMA,EAAW,IAAIC,KAAJ,gBAA8B,CAAEC,SAAS,IAEpDC,EAAY,CAAC,EAAD,MAEP,CAAC,EAAD,KACH,MAAMC,EAAOC,EAAb,GACMC,EAAOD,EAAb,GAEA,GAAID,GAAJ,EAAkB,CACd,MAAMG,EAAKH,EAAX,GACMI,EAAKF,EAAX,GACA,OAAON,EAAAA,QAAAA,EAAAA,GAAP,EAGJ,OAAOI,EAAOK,EAAgBH,GAAI,EAAlC,GCZFI,EAAa,CAAC,EAAD,QAA4DC,EAA5D,KAEf,MAAMC,EAAcC,EAApB,SAEA,GAAIF,EAAeG,EAAnB,EACI,IAAK,IAAL,OACI,GACIJ,EAAW,EAAD,QAAwDC,EAAlED,OAIR,CACA,MAAMK,EAAeZ,EAAU,EAAD,EAA9B,GAEA,IAAK,IAAL,OACI,GACIa,EAAAA,KAAAA,KClBVC,EAAgB,CAAC,EAAD,EAA8BC,EAA9B,GAA2CN,EAA3C,GAA6DO,EAA7D,MAClB,MACA,IAAK,IAAK,EAAV,OACI,KAAc,CACV,MAAMC,EAAeF,EAAAA,OAArB,GACAG,GAAOT,EAAAA,KAAPS,GACAF,EAAAA,KAAAA,GACKG,EAAAA,IAAL,KACQC,MAAAA,QAAJ,GACIJ,EAAAA,KAAAA,MAAAA,EAAAA,GAGAF,EAAc,EAAD,MAAbA,IAMhB,MAAO,eAAeE,WAAAA,ICV1B,MAAMK,EAAY,KAAlB,EAqFA,QAnFA,cCVA,MAAW,uGASM,IATN,qFAcW,IAdX,IAgBPC,aAAa,EAAD,GACR,EACIC,KAAA,iBAA8BC,EAA9B,eAGAD,KAAA,qBAIRE,gBACIF,KAAA,SAAgBA,KAAhB,QAGJG,WAAW,GACHH,KAAKI,cAAT,IACIJ,KAAA,mBAEJA,KAAA,cAGJK,YAAY,GACRL,KAAA,YAGJM,YAAY,GACHN,KAAKO,UAAUC,SAApB,KACIR,KAAA,kBACAA,KAAA,yBAIRS,qBAAqB,GACbT,KAAKJ,gBAAgBc,IAAzB,GACIV,KAAA,0BAGAA,KAAA,uBAIRW,eAAe,GACX,MAAMhB,EAAMK,KAAKO,UAAUK,QAA3B,IACA,IAAIjB,IACAK,KAAA,sBACAA,KAAA,yBAIRa,MAAM,GACFC,OAAAA,OAAAA,KAAAA,KDrDc,qBACd,OAAOd,KAAKe,QAAQC,QAAQC,IAAQjB,KAAKO,UAAUC,SAAUS,EAA7D,WAGwB,+BACxB,OAAOjB,KAAKO,UAAUW,KAAKC,GAAWnB,KAAKe,QAAQK,MAAMC,GAAKA,EAAAA,UAAxB,yBAAtC,KAGO,cACP,MJrBa,EAAC,EAAD,SAEjB,MAAMC,EAAiBC,EAAAA,OAAvB,EAQMC,EAAmBD,EAAzB,GACMpC,EAAY,IAAlB,IAGA,IAAK,IAAL,OAAmC,CAI/B,MAAMsC,EAAM9C,EAAZ,GAEA,MACI,SAGJ,QAAI+C,EAAJ,EAOA,IAAK,IAAIC,EAAT,EAAgBA,EAAhB,EAAoCA,IAAK,CAGrC,GAFAC,EAAYH,EAAKF,EAAjBK,IACAC,EAAiBH,EAAAA,IAAjBG,IACA,EAAqB,CACjBA,EAAiB,IAAjBA,IACA,IAAK,IAAL,KAA0BC,EAA1B,GACSJ,EAAAA,IAAL,IACIA,EAAAA,IAAAA,EAAAA,MAGRA,EAAAA,IAAAA,EAAAA,GAEJA,EAAAA,EAMJ,GAHAE,EAAYH,EAAZG,GACAC,EAAiBH,EAAAA,IAAjBG,GAEA,EACIA,EAAAA,KAAAA,OAEC,CACD,IAAK,IAAL,KAA0BC,EAA1B,GACSJ,EAAAA,IAAL,IACIA,EAAAA,IAAAA,EAAAA,MAGRA,EAAAA,IAAAA,EAA4B,CAA5BA,KAIR,UIzCWK,CAAc/B,KAAF,gBAAwBA,KAAxB,UAAwCA,KAAxC,WAAyDA,KAA5E,0BAGa,oBAIb,OAHIA,KAAJ,aACIhB,EAAYgB,KAAF,QAAgBA,KAAhB,WAAiCA,KAAjC,YAAmDA,KAAnD,cAAuEA,KAAKO,UAAtFvB,QAEGgB,KAAP,QAGe,sBACf,OAAOT,EAAeS,KAAF,cAAsBA,KAA1C,iBAGe,sBACf,MEpCmB,EAAC,EAAD,OACvB,GAAIgC,EAAJ,KAAqB,CAEjB,MAAMC,EAAN,GAEAC,EACA,IAAK,IAAL,EAASC,EAAJ,EAAgBA,EAArB,EAAuCA,IAGnC,GAFAV,EAAM9C,EAAN8C,GAEA,EAAS,CACL,IAAK,MAAO,EAAZ,OACI,KAAO,GAAKA,EAAP,2BAAL,GACI,WAIRQ,EAAAA,KAAAA,GAIR,SAGJ,OAAOpC,MAAA,KAAW,CAAEuC,OAAQC,IAAgB,CAAC,EAAD,IAA5C,KFaWC,CAAoBtC,KAAF,aAAqBA,KAArB,WAAsCA,KAA/D,YAGqB,4BACrB,OAAOA,KAAKI,YAAcJ,KAAKuC,gBAAgBC,KAAM/D,EAAWuB,KAAF,WAAmBA,KAAnB,YAAqCA,KAA5F,gBAAqHA,KAA5H,gBAGmB,0BACnB,OAAOA,KAAKyC,gBAAZ,WAGW,kBACX,QAASzC,KAAKO,UAAd,OAGY,mBACZ,OAAOP,KAAK0C,YAAc1C,KAAnB,oBAA8CA,KAArD,sBAGJ2C,cACIC,SAEAC,EAAAA,EAAAA,IAAe,KAAO,CAClBC,QADkB,KAElBL,gBAFkB,KAGlBF,gBAHkB,KAIlBG,YAJkB,KAMlBK,gBAAgBC,EAAAA,EAAAA,IAAS,CAAEC,OAAQC,EAAAA,GAAAA,aACnCpB,0BAA0BkB,EAAAA,EAAAA,IAAS,CAAEC,OAAQC,EAAAA,GAAAA,aAE7CC,cAAcH,EAAAA,EAAAA,IAAS,CAAEC,OAAQnD,IACjCsD,uBAAuBJ,EAAAA,EAAAA,IAAS,CAAEC,OAAQnD,IAC1CuD,eAAeL,EAAAA,EAAAA,IAAS,CAAEC,OAAQnD,IAElCuC,cAbkB,EAclB1D,YAdkB,EAelBoC,SAfkB,EAgBlBuC,SAhBkB,EAiBlBtB,YAjBkB,EAkBlBzB,WAlBkB,EAmBlBH,aAnBkB,EAoBlBrB,eApBkB,EAqBlBa,iBArBkB,EAuBlBG,aAvBkB,KAwBlBG,cAxBkB,KAyBlBC,WAzBkB,KA0BlBE,YA1BkB,KA2BlBC,YA3BkB,KA4BlBG,qBA5BkB,KA6BlBE,eA7BkB,KA8BlBE,MAAO0C,EAAAA,gNG/EbC,GAA4BC,EAAAA,EAAAA,KAAS,EAAC,sBAAqB9B,EAAAA,MAE7D,MAAO,CAAD,IAAgB+B,EAAAA,EAAAA,IAAQ,KAAM,CAChCC,KALR,IAMQC,KAAM,CACFzC,QAAAA,MAEL,CALH,IAOA,OACI,iBACI0C,IADJ,EAEIC,UAAWC,EACXC,QAAS,IAAMC,EAAAA,WAHnB,GAII,YAAWA,EAAAA,cAAAA,EAA2BA,IAAAA,EAAAA,cAAAA,YAA3BA,kBAJf,YAMK,IAAAtC,GAAU,iBAAM,iBAAgBsC,EAAAA,QAAAA,QAAtB,EAA8CD,QAAS,IAAMC,EAA7D,gBAAgFH,UAAWC,IAN1G,aAYFG,GAA4BT,EAAAA,EAAAA,KAAS,EAAC,IAAKtC,QAAAA,KAAc8C,EAAAA,QAAAA,MAC3D,kBACIH,UAAWC,EACX9D,MAAOgE,EAAAA,WAAAA,IAAAA,IAFX,GAGIE,SAAUC,GAAKH,EAAAA,aAAAA,EAAyBG,EAAAA,OAAzBH,WAIjBI,EAAW5E,IAEb,IAAI6E,EAAJ,EAEA,GAAIzE,MAAAA,QAAJ,GACIyE,GAAS7E,EAAT6E,YAGA,IAAK,IAAL,KAAmB7E,EAAnB,SACI,IACI6E,GAASD,EAATC,IAKZ,UAGEC,EAAS,CAAC,EAAD,OAEX,IAAID,EAAJ,EAEA,GAAIzE,MAAAA,QAAJ,GAAiC,CAC7B,MACA,IAAK,MAAL,OACI4B,EAAM9C,EAAN8C,GACA,IACI6C,GAAS7C,EAAT6C,SAKR,IAAK,MAAL,KAAqB7E,EAArB,SACI,IACI6E,GAASC,EAAO,EAAD,EAAfD,IAKZ,UAGEE,GAA4Bf,EAAAA,EAAAA,KAAS,EAAC,aAAahE,WAAAA,MAErD,aAAIgF,EAAAA,OACA,OAAOJ,EAAP,GAGJ,WAAII,EAAAA,OAAyB,CACzB,MAAMC,EAAMH,EAAO,EAAaE,EAAd,QAA8BR,EAAhD,YACMU,EAAKF,EAAAA,aAAsBA,EAAjC,OACA,OAAOE,EAAKA,EAAH,GAAT,EAGJ,eAGEC,EAAoB,EAAC,qBAAqBC,SAAAA,MAC5C,gBAAKf,UAAWC,EAAgBe,cAAhC,WACK/D,EAAAA,MAAcE,GAAOA,EAAAA,UAArBF,IAAgDgE,QAInDC,GAA4BvB,EAAAA,EAAAA,KAAS,EAAC,IAAKwB,WAAAA,MAE7C,MAAO,EAAD,IAA8BC,EAAAA,EAAAA,IAAQ,KAAM,CAC9CC,OAlGR,IAmGQC,KAAK,GACDnB,EAAAA,YAAeL,EAAfK,aAEJ,CALJ,IAOA,OAAOA,EAAAA,QAAAA,MACH,gBAAKH,UAAWC,EAAiBF,IAAjC,WACKI,EAAAA,UAAAA,OAAqBA,EAAA,eAAiBoB,IACnC,YAEIA,SAFJ,EAGItE,QAASkD,EAHb,QAIIY,SAAU,IAAMZ,EAAAA,eAAAA,IALvBA,KAOI,mDAOXqB,GAA0B7B,EAAAA,EAAAA,KAAS,EAAC,cAAc9D,IAAAA,MAEpD,MAAM4F,EAActB,EAAAA,gBAAAA,IAApB,GAEA,GAAIA,EAAJ,YAAmB,CAEf,MAAMuB,EAAYvB,EAAAA,gBAAAA,aAAlB,GAEA,KAAe,CAEX,MAAM3C,EAAiBkE,EAAAA,OAAvB,EACMH,EAAWpB,EAAAA,UAAjB,IAEM,+BAAwBwB,GAAWxB,EAAAA,QAAAA,MAAgB5C,GAAKA,EAAAA,UAA9D,IACMqE,EAAaF,EAAnB,GAEA,OACI,iCACI,iBACI1B,UAAWC,EACXC,QAAS,IAAMC,EAAAA,qBAFnB,GAGI,iBAAgBsB,EAAW,QAH/B,EAIII,MAAO,CACHC,WAAgC,EAAhBtE,EAAH,QANzB,IAUKuE,EAAcA,EAAD,IACV,uCACmBJ,EAAOA,EAAD,GAAoB,GAD7C,KAIH1E,EAAA,QACG,iBAAM+C,UAAWC,EAAjB,SACKhD,EAAAA,KAAaE,IAAOA,OAAAA,EAAA,QACjB,4BACKA,EADL,aAGI,YACIgD,EADJ,EAEIQ,OAFJ,EAGIhF,YA3CtB,EA2C2CwE,EAAD,QA3C3C,EA2C2C,EA3C1B6B,EAAAA,QAAY,CAAC,EAAD,IAAgBC,EAAAA,IAA5BD,IAAlC,QAqC2C7E,EADM,SAApBF,KApCZ,IAAC,EAAD,OAmBD,SAoCZ,eAGEiF,EAAe,IAAgG,IAA/F,6DAAgDf,EAAaL,GAAkC,EAAZqB,GAAY,YAEjH,MAAO,IAAOC,EAAAA,EAAAA,WAAS,IAAM,IAA7B,KAGM,aAAE/C,GAAR,GA4BAgD,EAAAA,EAAAA,YAAU,IAAMlC,EAAA,MAAQ,6BAA4BlD,QAAAA,KAAY,CAAC,EAAD,EAAhEoF,KAEAA,EAAAA,EAAAA,YAAU,KACN,MAAMC,EAAsBnC,EAAAA,eAAAA,QAAAA,MAElB,CAAC,EAAD,KAAcoC,EAAAA,qBAAF,IAAmCC,EAAAA,qBAF7BrC,KAAAA,QAGfhD,GAAOA,EAHQgD,uBAAAA,KAIlBhD,GAAOA,EAJjB,UAMAgD,EAAAA,YAAAA,KAPJkC,IAwBA,OACI,iBAAKrC,WAAWyC,EAAAA,EAAAA,IAAGxC,EAAnB,cACI,YAAaE,EAAb,EAAmBgB,WAAYA,KAC/B,6BACIlE,QAASkD,EADb,eAEI5B,aAAcc,EAFlB,OAGIxE,WAHJ,EAII6H,UA3DM,CAAC,EAAD,KAEd,MAAMC,EAAetD,EAArB,GAEA,OAAOsD,EAAAA,GACH,yBACI,eAAIC,QAASC,EAAAA,QAAb,iBACI,YAAW1C,EAAX,EAAiBtE,IAAjB,EAAoCoB,QAAS4F,EAAS5F,aAH3D0F,IAOH,mBAACE,EAAD,wBAEIC,IAFJ,EAGIC,MAAOJ,MA8CPK,kBAzCc/F,GAAWA,EAAA,KAAY,EAAC,kBAAkBgG,SAAAA,GAAnB,KAC7C,gBAAkBpB,MAAO,CAAEoB,SAAAA,GAA3B,WACI,YAAa9C,EAAb,EAAmB9C,QAAnB,EAAqC4D,MAArC,EAAmDpD,EAAGA,KACtD,YAAasC,EAAb,EAAmB9C,QAASA,MAHpC,KA0CY6F,mBAvBeC,GAA4BA,EAAA,MAA+BhG,KAASA,EAAxC,UACnD,wBACKgG,EAAAA,KAA8BhG,IAC3B,yBACI,YAAagD,EAAb,EAAmBQ,OAAnB,EAAgChF,WAAYwE,EAAE1B,mBADzCtB,EADZgG,aAFT,MAeI,QAeR,GAA6BxD,EAAAA,EAAAA,IAA7B,2BC/PA,MAAMyD,EAAOrH,MAAMsH,KAAK,CAAE/E,OAAQ,MAAS,CAACgF,EAAGzF,KAAJ,CACvCA,EAAAA,EACA0F,WAAY1F,EAAI,EAChB2F,UAAWC,IAAAA,KAAAA,YACXC,SAAUD,IAAAA,KAAAA,WACVE,QAASF,IAAAA,QAAAA,cA+Cb,EAzCqB,KACjB,SAAC,EAAD,CACIlF,aAAc6E,EAAK9E,OACnBzD,WAAYgD,GAAKuF,EAAMvF,GACvB+F,mBAAoB,GACpB3G,QAAS,CACL,CACII,QAAS,IACT4D,MAAO,IACP4C,OAAQ,MACRC,OAAQC,IACJ,uBAAKlC,MAAO,CACRmC,MAAO,OACPC,UAAW,SACXC,YAhBQC,EAgB+BJ,EAhBnB,GAAOI,EAAW,GAASA,EAAW,IAgB7C,KACbC,WAAa,OAAe,GAATL,EAAY,gBAJnC,SAMKA,IAnBOI,IAAAA,IAuBpB,CACI9G,QAAS,aACTsE,OAAQ2B,GAAM,MAAKA,IACnBrC,MAAO,KACPoD,qBAAsB,EACtBC,oBAAqB,CAAE,EAAG,EAAG,GAAI,IAErC,CACIjH,QAAS,YACT4D,MAAO,aACPoD,qBAAsB,EACtBC,oBAAqB,CAAE,UACvBT,OAAQ,SAEZ,CAAExG,QAAS,WAAY4D,MAAO,aAC9B,CAAE5D,QAAS,UAAW4D,MAAO","sources":["webpack://website/../src/models/aggregators/utils/multiGroupBy/index.js","webpack://website/../src/models/aggregators/utils/getSorter/index.js","webpack://website/../src/models/aggregators/utils/sortGroups/index.js","webpack://website/../src/models/aggregators/utils/flattenGroups/index.js","webpack://website/../src/models/aggregators/Mobx/index.js","webpack://website/../src/models/aggregators/Base/index.js","webpack://website/../src/models/aggregators/utils/getFilteredIndexes/index.js","webpack://website/../src/components/Table/index.js","webpack://website/./src/examples/complexTable(unstable)/basic/index.js"],"sourcesContent":["const multiGroupBy = ( indexesArray, groupDataKeysList, getRowData, priorityGroupValuesArray ) => {\n\n    const lastGroupIndex = groupDataKeysList.length - 1;\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( lastGroupIndex < 0 ){\n            throw new Error( \"lastGroupIndex < 0\" );\n        }\n    }\n\n    const lastGroupDataKey = groupDataKeysList[ lastGroupIndex ];\n    const groupsMap = new Map();\n   \n\n    for( let rowIndex of indexesArray ){\n        /*\n            It is better to start from indexes iteration, not from groups, to minimize getRowData calls\n        */\n        const row = getRowData( rowIndex );\n\n        if( !row ){\n            continue;\n        }\n\n        let innerObject = groupsMap,\n            tmpInnerObject,\n            cellValue;\n\n        /*\n            We could put everything in one loop, but last iteration is different.\n        */\n        for( let i = 0; i < lastGroupIndex; i++ ){\n            cellValue = row[ groupDataKeysList[ i ] ];\n            tmpInnerObject = innerObject.get( cellValue );\n            if( !tmpInnerObject ){\n                tmpInnerObject = new Map();\n                for( let priorityValue of priorityGroupValuesArray[ i ] ){\n                    if( !innerObject.has( priorityValue ) ){\n                        innerObject.set( priorityValue, null );\n                    }\n                }\n                innerObject.set( cellValue, tmpInnerObject );\n            }\n            innerObject = tmpInnerObject;\n        }\n\n        cellValue = row[ lastGroupDataKey ];\n        tmpInnerObject = innerObject.get( cellValue );\n\n        if( tmpInnerObject ){\n            tmpInnerObject.push( rowIndex );\n        }\n        else {\n            for( let priorityValue of priorityGroupValuesArray[ lastGroupIndex ] ){\n                if( !innerObject.has( priorityValue  ) ){\n                    innerObject.set( priorityValue, null );\n                }\n            }\n            innerObject.set( cellValue, [ rowIndex ]);\n        }\n    }\n\n    return groupsMap;\n}\n\nexport default multiGroupBy;","const collator = new Intl.Collator( undefined, { numeric: true });\n\nconst getSorter = ( getRowData, sortDataKey, sortDirection ) => {\n\n    return ( a, b ) => {\n        const row1 = getRowData( a );\n        const row2 = getRowData( b );\n\n        if( row1 && row2 ){\n            const v1 = row1[ sortDataKey ];\n            const v2 = row2[ sortDataKey ];\n            return collator.compare( v1, v2 ) * sortDirection;\n        }\n\n        return row1 ? sortDirection : row2 ? -sortDirection : 0;\n    }\n}\n\nexport default getSorter;","import getSorter from \"../getSorter\";\n\nconst sortGroups = ( groupsMap, getRowData, sortDataKey, sortDirection, depth, currentDepth = 0 ) => {\n\n    const groupValues = groupsMap.values();\n\n    if( currentDepth < depth - 1 ){\n        for( let group of groupValues ){\n            if( group ){\n                sortGroups( group, getRowData, sortDataKey, sortDirection, depth, currentDepth + 1 );\n            }\n        }\n    }\n    else{\n        const sortCallback = getSorter( getRowData, sortDataKey, sortDirection );\n\n        for( let group of groupValues ){\n            if( group ){\n                group.sort( sortCallback );\n            }\n        }\n    }\n}\n\nexport default sortGroups;","const flattenGroups = ( groupsMap, collapsedGroups, prefix = [], groupValues = [], rowIndexes = [] ) => {\n    let idx;\n    for( let [ groupValue, subGroup ] of groupsMap ){\n        if( subGroup ){\n            const concatenated = prefix.concat( groupValue );\n            idx = -groupValues.push( concatenated );\n            rowIndexes.push( idx );\n            if( !collapsedGroups.has( idx ) ){\n                if( Array.isArray( subGroup ) ){\n                    rowIndexes.push.apply( rowIndexes, subGroup );\n                }\n                else{\n                    flattenGroups( subGroup, collapsedGroups, concatenated, groupValues, rowIndexes );\n                }\n            }\n        }\n    }\n\n    return { groupValues, rowIndexes };\n}\n\nexport default flattenGroups;","import { makeObservable, action, comparer, computed } from \"mobx\"; \nimport multiGroupBy from \"../utils/multiGroupBy\";\nimport sortGroups from \"../utils/sortGroups\";\nimport flattenGroups from \"../utils/flattenGroups\";\nimport getSorter from \"../utils/getSorter\";\nimport getFilteredIndexes from \"../utils/getFilteredIndexes\";\nimport Base from \"../Base\";\n\nconst stubFalse = () => false;\n\nclass Mobx extends Base {\n\n    get visibleColumns(){\n        return this.columns.filter( col => !this.groupKeys.includes( col.dataKey ) );\n    }\n\n    get priorityGroupValuesArray(){\n        return this.groupKeys.map( dataKey => this.columns.find( c => c.dataKey === dataKey ).priorityGroupValues || [] );\n    }\n\n    get grouped(){\n        return multiGroupBy( this.filteredIndexes, this.groupKeys, this.getRowData, this.priorityGroupValuesArray );\n    }\n\n    get groupedSorted(){\n        if( this.sortDataKey ){\n            sortGroups( this.grouped, this.getRowData, this.sortDataKey, this.sortDirection, this.groupKeys.length );\n        }\n        return this.grouped;\n    }\n\n    get flattenedGroups(){\n        return flattenGroups( this.groupedSorted, this.collapsedGroups );\n    }\n\n    get filteredIndexes(){\n        return getFilteredIndexes( this.rowsQuantity, this.getRowData, this.filtersMap );\n    }\n\n    get noGroupsSortedIndexes(){\n        return this.sortDataKey ? this.filteredIndexes.sort( getSorter( this.getRowData, this.sortDataKey, this.sortDirection ) ) : this.filteredIndexes;\n    }\n\n    get groupsSortedIndexes(){\n        return this.flattenedGroups.rowIndexes;\n    }\n\n    get hasGrouping(){\n        return !!this.groupKeys.length;\n    }\n\n    get finalIndexes(){\n        return this.hasGrouping ? this.groupsSortedIndexes : this.noGroupsSortedIndexes;\n    }\n\n    constructor(){\n        super();\n\n        makeObservable( this, {\n            grouped: computed,\n            flattenedGroups: computed,\n            filteredIndexes: computed,\n            hasGrouping: computed,\n            \n            visibleColumns: computed({ equals: comparer.structural }),\n            priorityGroupValuesArray: computed({ equals: comparer.structural }),\n            \n            finalIndexes: computed({ equals: stubFalse }),\n            noGroupsSortedIndexes: computed({ equals: stubFalse }),\n            groupedSorted: computed({ equals: stubFalse }),\n\n            rowsQuantity: true,\n            getRowData: true,\n            columns: true,\n            compact: true,\n            filtersMap: true,\n            groupKeys: true,\n            sortDataKey: true,\n            sortDirection: true,\n            collapsedGroups: true,\n        \n            setFiltering: action,\n            toggleCompact: action,\n            setSorting: action,\n            setGrouping: action,\n            addGrouping: action,\n            toggleCollapsedGroup: action,\n            removeGrouping: action,\n            merge: action,\n        });\n    }\n}\n\nexport default Mobx;","class Base {\n\n    /* Provided from renderer */\n    rowsQuantity = 0;\n    getRowData = null;\n    columns = [];\n    compact = true;\n\n    /* Calculated inside model */\n    filtersMap = new Map();\n    groupKeys = [];\n    sortDataKey = \"\";\n    sortDirection = -1;\n\n    collapsedGroups = new Set();\n\n    setFiltering( dataKey, value ){\n        if( value ){\n            this.filtersMap.set( dataKey, value.toLowerCase() );\n        }\n        else{\n            this.filtersMap.delete( dataKey );\n        }\n    }\n\n    toggleCompact(){\n        this.compact = !this.compact;\n    }\n\n    setSorting( dataKey ){\n        if( this.sortDataKey === dataKey ){\n            this.sortDirection *= -1;\n        }\n        this.sortDataKey = dataKey;\n    }\n\n    setGrouping( dataKeysArray ){\n        this.groupKeys = dataKeysArray;\n    }\n\n    addGrouping( dataKey ){\n        if( !this.groupKeys.includes( dataKey ) ){\n            this.groupKeys.push( dataKey );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    toggleCollapsedGroup( idx ){\n        if( this.collapsedGroups.has( idx ) ){\n            this.collapsedGroups.delete( idx );\n        }\n        else{\n            this.collapsedGroups.add( idx );\n        }\n    }\n\n    removeGrouping( dataKey ){\n        const idx = this.groupKeys.indexOf( dataKey );\n        if( idx !== -1 ){\n            this.groupKeys.splice( idx, 1 );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    merge( propertiesObj ){\n        Object.assign( this, propertiesObj );\n    }\n}\n\nexport default Base;","const getFilteredIndexes = ( rowsQuantity, getRowData, filtersMap ) => {\n    if( filtersMap.size ){\n\n        const result = [];\n\n        mainLoop:\n        for( let j = 0, row; j < rowsQuantity; j++ ){\n            row = getRowData( j );\n\n            if( row ){\n                for( const [ dataKey, value ] of filtersMap ){\n                    if( !( \"\" + row[ dataKey ] ).toLowerCase().includes( value ) ){\n                        continue mainLoop;\n                    }\n                }\n\n                result.push( j );\n            }            \n        }\n\n        return result;\n    }\n\n    return Array.from({ length: rowsQuantity }, ( v, i ) => i );\n}\n\nexport default getFilteredIndexes;","import { Fragment, useState, useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport RowsAggregator from \"src/models/aggregators/Mobx\";\nimport { Table, cx } from \"af-virtual-scroll\";\nimport css from \"./style.module.scss\";\nimport { useDrag, useDrop } from \"react-dnd\";\n\nconst HEADER_DND_TYPE = \"h\";\n\nconst HeaderLabel = /*#__PURE__*/ observer(({ m, dataKey, label, i }) => {\n\n    const [ , dragRef ] = useDrag(() => ({\n        type: HEADER_DND_TYPE,\n        item: {\n            dataKey\n        }}\n    ), [ dataKey ]);\n\n    return (\n        <div\n            ref={dragRef}\n            className={css.sortableHeader}\n            onClick={() => m.setSorting( dataKey )}\n            aria-sort={m.sortDataKey === dataKey?(m.sortDirection===1?\"ascending\":\"descending\"):undefined}\n        >\n            {i === 0 ? <span data-collapsed={m.compact?\"\":undefined} onClick={() => m.toggleCompact()} className={css.compactToggler} /> : null}\n            {label}\n        </div>\n    );\n});\n\nconst HeaderInput = /*#__PURE__*/ observer(({ m, dataKey }) => m.compact ? null : (\n    <input\n        className={css.input}\n        value={m.filtersMap.get( dataKey )||\"\"}\n        onChange={e => m.setFiltering( dataKey, e.target.value )}\n    />\n));\n\nconst getCount = rowIndexes => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        total += rowIndexes.length;\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            if( nested ){\n                total += getCount( nested );\n            }\n        }\n    }\n\n    return total;\n}\n\nconst getSum = ( rowIndexes, dataKey, getRowData ) => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        let row;\n        for( const j of rowIndexes ){\n            row = getRowData( j );\n            if( row ){\n                total += row[ dataKey ];\n            }\n        }\n    }\n    else {\n        for( const nested of rowIndexes.values() ){\n            if( nested ){\n                total += getSum( nested, dataKey, getRowData );\n            }\n        }\n    }\n\n    return total;\n}\n\nconst SummaryCell = /*#__PURE__*/ observer(({ m, column, rowIndexes }) => {\n\n    if( column.totals === \"count\" ){\n        return getCount( rowIndexes );\n    }\n\n    if( column.totals === \"sum\" ){\n        const sum = getSum( rowIndexes, column.dataKey, m.getRowData );\n        const fn = column.formatTotal || column.format;\n        return fn ? fn( sum ) : sum;\n    }\n\n    return null;\n});\n\nconst GroupLabelDefault = ({ groupKey, columns, onRemove }) => (\n    <div className={css.groupLabel} onDoubleClick={onRemove}>\n        {columns.find( col => col.dataKey === groupKey ).label}\n    </div>\n);\n\nconst GroupsPanel = /*#__PURE__*/ observer(({ m, GroupLabel }) => {\n\n    const [ collectedProps, dropRef ] = useDrop(() => ({\n        accept: HEADER_DND_TYPE,\n        drop( item ){\n            m.addGrouping( item.dataKey );\n        }\n    }), [ m ]);\n\n    return m.compact ? null : (\n        <div className={css.groupsPanel} ref={dropRef}>\n            {m.groupKeys.length ? m.groupKeys.map( groupKey => (\n                <GroupLabel\n                    key={groupKey}\n                    groupKey={groupKey}\n                    columns={m.columns}\n                    onRemove={() => m.removeGrouping( groupKey )}\n                />\n            )) : \"Drag column headers here to group by column\" }\n        </div>\n    );\n});\n\nconst getInMap = ( map, path ) => path.reduce(( res, key ) => res.get( key ), map );\n\nconst GroupCell = /*#__PURE__*/ observer(({ m, columns, idx }) => {\n\n    const isCollapsed = m.collapsedGroups.has( idx );\n\n    if( m.hasGrouping ){\n\n        const groupPath = m.flattenedGroups.groupValues[~idx];\n\n        if( groupPath ){\n\n            const lastGroupIndex = groupPath.length - 1;\n            const groupKey = m.groupKeys[lastGroupIndex];\n            /* hidden columns also must be included */\n            const { getGroupLabel, label, format } = m.columns.find( c => c.dataKey === groupKey );\n            const groupValue = groupPath[lastGroupIndex];\n\n            return (\n                <Fragment>\n                    <span\n                        className={css.groupToggler}\n                        onClick={() => m.toggleCollapsedGroup( idx )}\n                        data-collapsed={isCollapsed?\"\":undefined}\n                        style={{\n                            marginLeft: `${(lastGroupIndex)*2}em`\n                        }}\n                    />\n                    &nbsp;\n                    {getGroupLabel?getGroupLabel(groupValue):(\n                        <Fragment>\n                            {label}:&nbsp;{format?format(groupValue):\"\"+groupValue}\n                        </Fragment>\n                    )}\n                    {columns.length ? (\n                        <span className={css.columnSummaries}>\n                            {columns.map( col => col.totals ? (\n                                <span key={col.dataKey}>\n                                    {col.label}:\n                                    &nbsp;\n                                    <SummaryCell\n                                        m={m}\n                                        column={col}\n                                        rowIndexes={getInMap(m.grouped,groupPath)}\n                                    />\n                                </span>\n                            ) : null)}\n                        </span>\n                    ) : null}\n                </Fragment>\n            );\n        }\n        \n    }\n\n    return null;\n});\n\nconst ComplexTable = ({ rowsQuantity, getRowData, className, columns, GroupLabel = GroupLabelDefault, ...props }) => {\n\n    const [ m ] = useState(() => new RowsAggregator());\n\n    /* hack to change renderRow by link */\n    const { finalIndexes } = m;\n\n    const renderRow = ( index, RowProps ) => {\n\n        const realRowIndex = finalIndexes[ index ];\n\n        return realRowIndex < 0 ? (\n            <tr key={index}>\n                <td colSpan={RowProps.columns.length}>\n                    <GroupCell m={m} idx={realRowIndex} columns={RowProps.columns} />\n                </td>\n            </tr>\n        ) : (\n            <RowProps.Row\n                {...RowProps}\n                key={index}\n                index={realRowIndex}\n            />\n        );\n    }\n\n    const renderHeaderCells = columns => columns.map(({ dataKey, label, minWidth }, i ) => (\n        <th key={dataKey} style={{ minWidth }}>\n            <HeaderLabel m={m} dataKey={dataKey} label={label} i={i} />\n            <HeaderInput m={m} dataKey={dataKey} />\n        </th>\n    ));\n\n    useEffect(() => m.merge({ rowsQuantity, getRowData, columns }), [ rowsQuantity, getRowData, columns ]);\n\n    useEffect(() => {\n        const initialGroupingKeys = m.visibleColumns\n            .slice()\n            .sort(( a, b ) => ( a.initialGrouingIndex || 0 ) - ( b.initialGrouingIndex || 0 ) )\n            .filter( col => col.initialGroupingIndex )\n            .map( col => col.dataKey );\n\n        m.setGrouping( initialGroupingKeys );\n    }, []);\n\n    const renderTfootContent = normalizedVisibleColumns => normalizedVisibleColumns.some( col => !!col.totals ) ? (\n        <tr>\n            {normalizedVisibleColumns.map( col => (\n                <td key={col.dataKey}>\n                    <SummaryCell m={m} column={col} rowIndexes={m.filteredIndexes} />\n                </td>\n            ))}\n        </tr>\n    ) : null;\n\n    /*\n        Normally must be wrapped with DndProvider, but nested providers throw error.\n        Waiting for react-dnd release, which would fix this\n    */\n    return (\n        <div className={cx(css.wrapper,className)}>\n            <GroupsPanel m={m} GroupLabel={GroupLabel} />\n            <Table\n                columns={m.visibleColumns}\n                rowsQuantity={finalIndexes.length}\n                getRowData={getRowData}\n                renderRow={renderRow}\n                renderHeaderCells={renderHeaderCells}\n                renderTfootContent={renderTfootContent}\n                {...props}\n            />\n        </div>\n    );\n}\n\nexport default /*#__PURE__*/ observer( ComplexTable );","import { Table } from \"af-react-table\";\nimport faker from \"faker\";\n\nconst rows = Array.from({ length: 10000 }, (v, i) => ({\n    i,\n    fixedRange: i % 9,\n    firstName: faker.name.firstName(),\n    lastName: faker.name.lastName(),\n    country: faker.address.country()\n}));\n\n/* Math.random is not the best option, because same rowIndex should produce same height */\nconst getPureRandomLineHeight = rowIndex => 20 + ( rowIndex % 53 ) + ( rowIndex % 87 );\n\nconst ComplexTable = () => (\n    <Table\n        rowsQuantity={rows.length}\n        getRowData={i => rows[ i ]}\n        estimatedRowHeight={30}\n        columns={[\n            {\n                dataKey: \"i\",\n                label: \"i\",\n                totals: \"sum\",\n                render: cellData => (\n                    <div style={{\n                        color: \"#000\",\n                        textAlign: \"center\",\n                        lineHeight: `${getPureRandomLineHeight(cellData)}px`,\n                        background: `hsl(${cellData*11%360},60%,60%)`\n                    }}>\n                        {cellData}\n                    </div>\n                )\n            },\n            {\n                dataKey: \"fixedRange\",\n                format: v => `fr ${v}`,\n                label: \"FR\",\n                initialGroupingIndex: 1,\n                priorityGroupValues: [ 4, 7, 71, 5 ]\n            },\n            {\n                dataKey: \"firstName\",\n                label: \"first name\",\n                initialGroupingIndex: 2,\n                priorityGroupValues: [ \"Dennis\" ],\n                totals: \"count\"\n            },\n            { dataKey: \"lastName\", label: \"last name\" },\n            { dataKey: \"country\", label: \"country\" }\n        ]}\n    />\n);\n\nexport default ComplexTable;"],"names":["collator","Intl","numeric","getSorter","row1","getRowData","row2","v1","v2","sortDirection","sortGroups","currentDepth","groupValues","groupsMap","depth","sortCallback","group","flattenGroups","prefix","rowIndexes","concatenated","idx","collapsedGroups","Array","stubFalse","setFiltering","this","value","toggleCompact","setSorting","sortDataKey","setGrouping","addGrouping","groupKeys","includes","toggleCollapsedGroup","has","removeGrouping","indexOf","merge","Object","columns","filter","col","map","dataKey","find","c","lastGroupIndex","groupDataKeysList","lastGroupDataKey","row","innerObject","i","cellValue","tmpInnerObject","priorityGroupValuesArray","multiGroupBy","filtersMap","result","mainLoop","j","length","rowsQuantity","getFilteredIndexes","filteredIndexes","sort","flattenedGroups","hasGrouping","constructor","super","makeObservable","grouped","visibleColumns","computed","equals","comparer","finalIndexes","noGroupsSortedIndexes","groupedSorted","compact","action","HeaderLabel","observer","useDrag","type","item","ref","className","css","onClick","m","HeaderInput","onChange","e","getCount","total","getSum","SummaryCell","column","sum","fn","GroupLabelDefault","onRemove","onDoubleClick","label","GroupsPanel","GroupLabel","useDrop","accept","drop","groupKey","GroupCell","isCollapsed","groupPath","format","groupValue","style","marginLeft","getGroupLabel","path","res","ComplexTable","props","useState","useEffect","initialGroupingKeys","a","b","cx","renderRow","realRowIndex","colSpan","RowProps","key","index","renderHeaderCells","minWidth","renderTfootContent","normalizedVisibleColumns","rows","from","v","fixedRange","firstName","faker","lastName","country","estimatedRowHeight","totals","render","cellData","color","textAlign","lineHeight","rowIndex","background","initialGroupingIndex","priorityGroupValues"],"sourceRoot":""}