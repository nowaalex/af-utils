{"version":3,"file":"72833d542750b1418df5.js","mappings":";qLAQA,MAAMA,EAAYC,GAAKA,EAAI,EAErBC,EAAoB,CAACC,EAAOC,EAAUC,KACxC,MAAMC,GAAgBC,EAAAA,EAAAA,QAAO,MACvBC,GAAcC,EAAAA,EAAAA,YAAWT,EAAW,GAAG,GAC7C,OAAOU,EAAAA,EAAAA,YAAW,KAAOP,EAAMQ,GAAGH,KAAgBH,GAAS,IAAMF,EAAMS,IAAIJ,KAAgBH,KAAWA,GACtGF,EAAMU,QAKNV,EAAMW,MAAMN,GAAeF,EAAcS,QAAUX,EAASD,GAAQG,EAAcS,SAKhFC,EAAc,CAAE,QAAS,WAAY,UAErCC,EAAW,CAAE,EAAG,GAEhBC,EAAYC,KAAKC,MAAMC,SAAS,IAEhCC,EAAOC,IACT,IAAKpB,MAAOA,EAAOqB,SAAUA,EAAzB,OAA2CC,EAAS,OAASF,EAAMG,GAAOC,EAAAA,EAAAA,GAA8BJ,EAAMP,GAClH,OAAOd,EAAkBC,GAAQ,EAAEyB,WAAYA,EAAYC,SAAUA,EAAUC,iBAAkBA,EAAkBC,cAAeA,MAC9H,MAAMC,EAAS,EAAgBC,EAAAA,EAAAA,KAAIR,EAAQ,CACvCS,UAZS,UAaT,cAAe,OACfC,MAAO,CACHC,OAAQN,GAEZO,IAAKN,GACNb,IACH,IAAK,IAAIoB,EAAIV,EAAYU,EAAIT,EAAUS,IAAKN,EAAOO,KAAKf,EAASc,EAAGZ,IACpE,OAAOM,IACPf,IAGFuB,EAAK,CAACC,EAAWC,IAAeA,EAAc,GAAED,KAAaC,IAAeD,EAE5EE,EAAY,IAAIC,IAEhBC,EAAI,IAAIC,gBAAgBC,IAC1B,IAAK,MAAOC,OAAQA,KAAWD,EAAS,CACpC,MAAME,EAAKN,EAAUO,IAAIF,GACzBC,GAAMA,EAAGD,OAIXG,EAAU,CAACC,EAAIhD,KACjBuC,EAAUU,IAAID,EAAIhD,GAAWyC,EAAEM,QAAQC,IAGrCE,EAAYF,GAAMT,EAAUY,OAAOH,IAAOP,EAAES,UAAUF,GAItDI,EAAS,CAAE,EAAG,GAEdC,EAAiB,EAAEtD,MAAOA,KAAWD,EAAkBC,GAAQuD,IAAqBzB,EAAAA,EAAAA,KAAI,MAAO,CACjG,cAAe,OACfC,UANkB,UAOlBC,MAAO,CACHC,OAAQsB,EAAIC,mBAAqBD,EAAIE,sBAExCJ,GAeL,MAAMK,UAAiB,MACnBC,cACIC,KAAKC,GAAKC,MAAMC,KAAK,CACjBC,OAAQ,IACR,IAAM,KAAMJ,KAAKK,GAAK,IAAIC,IAAKN,KAAKlD,QAAU,EAEtDyD,IAAIlE,EAAUC,EAAQkE,GAClB,IAAK,MAAMC,KAAOnE,EAAQ0D,KAAKC,GAAGQ,GAAKC,OAAOF,EAAgB,EAAI,WAAY,EAAGnE,GACjF,OAAO2D,KAEXpD,GAAGP,KAAaC,GACZ,OAAO0D,KAAKO,IAAIlE,EAAUC,GAAQ,GAEtCqE,gBAAgBtE,KAAaC,GACzB,OAAO0D,KAAKO,IAAIlE,EAAUC,GAAQ,GAEtCsE,aACI,IAAK,MAAMtE,KAAU0D,KAAKC,GAAI3D,EAAOoE,OAAO,GAC5CV,KAAKK,GAAGQ,QAEZhE,IAAIR,KAAaC,GACb,IAAK,MAAMmE,KAAOnE,EAAQ0D,KAAKC,GAAGQ,GAAKC,OAAOV,KAAKC,GAAGQ,GAAKK,QAAQzE,KAAc,EAAG,GACpF,OAAO2D,KAEXjD,MAAMmC,GAEFc,KAAKK,GAAGU,IAAI7B,GAEhB8B,KAAKP,GACD,GAAIT,KAAKlD,QAAS,IAAK,MAAMoC,KAAMc,KAAKC,GAAGQ,GAAMT,KAAKK,GAAGU,IAAI7B,QAAU,IAAK,MAAMA,KAAMc,KAAKC,GAAGQ,GAAMvB,EAAG+B,KAAKjB,MAC9G,OAAOA,KAEekB,aACtB,OAAOlB,KAAKlD,UAAWkD,KAE3BmB,WACI,MAAOnB,KAAKlD,QAAS,CACjB,IAAK,MAAMoC,KAAMc,KAAKK,GAAInB,EAAG+B,KAAKjB,MAClCA,KAAKK,GAAGQ,QAEZ,OAAOb,OAMXoB,uBAAuBC,GACnBrB,KAAKsB,oBAAsBD,GAAQ,KAEEE,aAAaC,GAClDA,IAAMxB,KAAKyB,YAAczB,KAAKyB,UAAYD,EAAGxB,KAAK0B,sBAEtDC,wBAAwBC,GACpBA,IAAU5B,KAAKH,mBAAqB+B,EAAO5B,KAAKgB,KAAK,IAEzDa,iBACI,MAAM/D,EAAWgE,KAAKC,IAAI/B,KAAKgC,SAAShC,KAAKyB,UAAYzB,KAAKiC,cAAgBjC,KAAKkC,kBAAmBlC,KAAKmC,cAC3G,OAAOrE,IAAakC,KAAKlC,WAAakC,KAAKlC,SAAWA,EAAUkC,KAAKgB,KAAK,IAAKhB,KAEnF0B,qBACI1B,KAAKkB,aACL,MAAMrD,EAAaiE,KAAKM,IAAI,EAAGpC,KAAKgC,SAAShC,KAAKyB,WAAazB,KAAKkC,mBACpE,OAAOrE,IAAemC,KAAKnC,aAAemC,KAAKnC,WAAaA,EAAYmC,KAAKjC,iBAAmBiC,KAAKqC,UAAUxE,GAC/GmC,KAAKgB,KAAK,IAAKhB,KAAK6B,iBAAiBV,WAEcmB,YACnD,OAAOtC,KAAKkB,aAAaqB,2BAA2Bb,qBAAqBP,WAE7EpB,cACIyC,QAASxC,KAAKyB,UAAY,EAAGzB,KAAKmC,aAAe,EAAGnC,KAAKkC,kBAAoB,EAC7ElC,KAAKiC,aAAe,EAAGjC,KAAKyC,YAAc,EAAGzC,KAAKH,kBAAoB,EAAGG,KAAK0C,mBAAqB,EACnG1C,KAAK2C,WAAa,KAAM3C,KAAKsB,oBAAsB,KAAMtB,KAAKhC,cAAgBqD,IAC1ErB,KAAK2C,WAAatB,GACnBrB,KAAK4C,uBAAyB,EAAEC,aAAcA,EAAcC,YAAaA,MACxE9C,KAAKkB,aAAc2B,IAAiB7C,KAAKiC,eAAiBjC,KAAKiC,aAAeY,EAC9E7C,KAAKgB,KAAK,IAAK8B,IAAgB9C,KAAKyC,cAAgBzC,KAAKyC,YAAcK,EACvE9C,KAAKgB,KAAK,IAAKhB,KAAKmB,YACrBnB,KAAK+C,qBA1FG,EAACC,EAAIC,EAAIC,KACxB,IAAIC,EAAQ,EACZ,MAAMC,EAAS,KACXD,EAAQ,EAAGH,EAAG/B,KAAKiC,IAEjBG,EAAY,KACd,IAAMF,IAAUA,EAAQG,WAAWF,EAAQH,KAE/C,OAAOI,EAAUE,OAAS,KACtBC,aAAaL,GAAQA,EAAQ,GAC9BE,GAgFgCI,CAAWzD,KAAK0D,YAAa,IAAK1D,MAAOA,KAAKnC,WAAa,EAC1FmC,KAAKlC,SAAW,EAAGkC,KAAKjC,iBAAmB,EAAGiC,KAAKJ,mBAAqB,EAAGI,KAAKpD,GAAGoD,KAAK+C,qBAAsB,EAAG,EAAG,GAAGnG,GAAGoD,KAAKuC,yBAA0B,GAAG3F,GAAGoD,KAAK6B,eAAgB,EAAG,GAE3LjB,aACIZ,KAAK+C,qBAAqBQ,SAAUf,MAAM5B,aAE9C+C,YAAYC,GACR5D,KAAKsB,sBAAsBtB,KAAKsB,oBAAoBG,UAAYzB,KAAKqC,UAAUuB,IAEnFrB,2BACI,MAAMf,EAAIxB,KAAKqC,UAAUrC,KAAKmC,cAC9B,OAAOX,IAAMxB,KAAKJ,qBAAuBI,KAAKJ,mBAAqB4B,EAAGxB,KAAKgB,KAAK,IAChFhB,KAEJ6D,UAAUnB,EAAoBR,EAAmBC,GAC7CnC,KAAK0C,mBAAqBA,EAAoB1C,KAAKkB,aAAcgB,IAAsBlC,KAAKkC,oBAAsBlC,KAAKkC,kBAAoBA,EAC3IlC,KAAKjD,MAAMiD,KAAK0B,qBAAsBS,IAAiBnC,KAAKmC,eAAiBnC,KAAKmC,aAAeA,EACjGnC,KAAKgB,KAAK,IAAKhB,KAAKmB,YAI5B,MAAM2C,EAAuB,cAAchE,EAKvCC,cACIyC,QAASxC,KAAK+D,WAAa,GAAI/D,KAAKgE,MAAQ,GAAIhE,KAAKiE,IAAM,EAAGjE,KACNW,gBAAgBX,KAAKkE,KAAM,GAAGtH,GAAGoD,KAAK+C,qBAAsB,EAAG,GAE3HmB,OACI,MAAO/B,aAAcA,GAAgBnC,KACrC,GAAImC,EAAe,GAAKA,EAAe,WAAY,MAAM,IAAIgC,MAAO,uBAAsBhC,iCAC1FnC,KAAKiE,IAAM9B,GAAgB,GAAK,GAAKL,KAAKsC,MAAMjC,GAChD,MAAMkC,EAAqBrE,KAAK+D,WAAW3D,OAC3C,GAAI+B,EAAekC,EAAoB,CACnC,MAAMC,EAAgBtE,KAAK+D,WAC3B/D,KAAK+D,WAAa,IAAIQ,YAAYpC,GAAenC,KAAKgE,MAAQ,IAAIO,YAAYpC,EAAe,GAC7FnC,KAAK+D,WAAWzE,IAAIgF,GAAgBtE,KAAK+D,WAAWS,KAAKxE,KAAK0C,mBAAoB2B,GAKlFrE,KAAKgE,MAAM1E,IAAIU,KAAK+D,WAAY,GAChC,IAAK,IAAIU,EAAGlG,EAAI,EAAGA,GAAK4D,EAAc5D,IAAKkG,EAAIlG,GAAKA,GAAKA,GAAIkG,GAAKtC,IAAiBnC,KAAKgE,MAAMS,IAAMzE,KAAKgE,MAAMzF,IAC/GyB,KAAKsC,aAGbN,SAAS0C,GACL,IAAIC,EAAQ,EACZ,IAAK,IAAIC,EAAWC,EAAU7E,KAAKiE,IAAK,IAAMY,EAASA,IAAY,EAAG,GAAID,EAAYD,EAAQE,IAC5FD,EAAY5E,KAAKmC,cAAe,CAC9B,GAAIuC,IAAW1E,KAAKgE,MAAMY,GAAY,OAAOA,EAC7CF,EAAS1E,KAAKgE,MAAMY,KAAeF,GAAU1E,KAAKgE,MAAMY,GAAYD,EAAQC,GAEhF,OAAOD,EAEXtC,UAAUsC,GAEN,IAAI1G,EAAS,EACb,KAAM0G,EAAQ,EAAGA,GAASA,GAASA,EAAO1G,GAAU+B,KAAKgE,MAAMW,GAC/D,OAAO1G,EAEoB6G,gBAAgBvG,EAAGqD,EAAOmD,GACrD,KAAMxG,EAAIwG,EAAuBxG,GAAKA,GAAKA,EAAGyB,KAAKgE,MAAMzF,IAAMqD,EAEnE8B,cACI,IAAIsB,EACJ,IAAIC,EAAQ,OAASD,EAAmBhF,KAAK2C,iBAAc,EAASqC,EAAiBE,mBACrF,GAAID,EAAO,CACP,IAAIE,EAAMR,EAAQ3E,KAAKnC,WAAYuH,EAAO,EACiE,MAAMC,EAAMvD,KAAKC,IAAI/B,KAAKgE,MAAM5D,OAAQ,GAAK,GAAK0B,KAAKsC,MAAMpE,KAAKlC,SAAW,IACxL,GACIqH,EAAOF,EAAMpC,aAAe7C,KAAK+D,WAAWY,GAAQQ,IAASnF,KAAK+D,WAAWY,IAAUQ,EACvFC,GAAQD,EAAMnF,KAAK8E,gBAAgBH,EAAQ,EAAGQ,EAAME,YAC7CV,EAAQ3E,KAAKlC,WAAamH,EAAQA,EAAMC,qBACnDE,IAASpF,KAAK8E,gBAAgBO,EAAKD,EAAMpF,KAAKgE,MAAM5D,QAASJ,KAAKsC,gBAKxEgD,EAAoB,cAAcxF,EACpCC,eAAewF,GACX/C,SAAS+C,GAAOvF,KAAKwF,UAAY,EAErCC,aAAajE,GACTA,IAAMxB,KAAKwF,YAAcxF,KAAKwF,UAAYhE,EAAGxB,KAAKsC,aAEtDN,SAAS0C,GAEL,OAAO1E,KAAKwF,WAAa1D,KAAK4D,MAAMhB,EAAS1E,KAAKwF,WAEtDnD,UAAUsC,GACN,OAAOA,EAAQ3E,KAAKwF,UAExB9B,cACI,GAAI1D,KAAKmC,aAAc,CACnB,IAAI6C,EACJ,MAAMW,EAAQ,OAASX,EAAmBhF,KAAK2C,iBAAc,EAASqC,EAAiBE,mBACvFS,GAAS3F,KAAKyF,aAAaE,EAAM9C,iBAOvC+C,EAAc,CAAE,eAAgB,WAAY,KAAM,QAAS,qBAAsB,oBAAqB,UAAW,iBAAkB,aAEnIC,EAAc,GAEdC,EAAYtI,IACd,IAAK2E,aAAcA,EAAc1E,SAAUA,EAAUsI,GAAIC,EAAY,MAAjE,MAA+EC,GAAQ,EAAvF,mBAA+GvD,EAAqB,GAApI,kBAA2JR,EAAoB,EAAGgE,QAASA,EAASC,eAAgBA,EAAgBhI,UAAWA,GAAaX,EAAM4I,GAAQxI,EAAAA,EAAAA,GAA8BJ,EAAMoI,GAClT,MAAOxJ,IAASiK,EAAAA,EAAAA,WAAU,IAAM,IAAKJ,EAAQX,EAAoBxB,MACjEwC,EAAAA,EAAAA,qBAAoBJ,GAAU,IAAM9J,GAAQyJ,GAC5C,MAAMU,GAAgBC,EAAAA,EAAAA,cAAaC,IAC/BrK,EAAMkF,qBAAuB/B,EAAUnD,EAAMkF,qBAAsBlF,EAAMgF,uBAAuBqF,GAChGA,GAAcrH,EAAQqH,EAAYrK,EAAMwG,0BACxCiD,GAiBJ,OAhBIzJ,EAAM8E,aAAa2C,UAAUnB,EAAoBR,EAAmBC,IACxExF,EAAAA,EAAAA,YAAW,KACPP,EAAM+E,eACLxE,EAAAA,EAAAA,YAAW,KACZ,GAAIwJ,EAAgB,CAChB,MAAM1F,EAAM,IAAM0F,EAAe/J,GACjC,OAAOqE,IAAOrE,EAAMQ,GAAG6D,EAAK,EAAG,GAAI,IAAMrE,EAAMS,IAAI4D,EAAK,EAAG,MAE/D,CAAE0F,KAAmBxJ,EAAAA,EAAAA,YAAW,IAAM,IAAMP,EAAMwE,cAAeiF,IAQ9Da,EAAAA,EAAAA,MAAKV,EAAWW,OAAOC,OAAO,GAAIR,EAAO,CAC5CS,SAAU,IACV1I,UAAWM,EAhCG,WAgCeN,GAC7BG,IAAKiI,EACLO,SAAUC,GAAK3K,EAAMmF,aAAawF,EAAE9H,OAAOwC,WAC3ChE,SAAU,EAAgBS,EAAAA,EAAAA,KAAIwB,EAAgB,CAC1CtD,MAAOA,IACPqB,EAASrB,QAcf4K,EAAc,CAAE,YAEhBC,EAAOzJ,IACT,IAAKC,SAAUA,GAAYD,EAAM4I,GAAQxI,EAAAA,EAAAA,GAA8BJ,EAAMwJ,GAE7E,OAAO9I,EAAAA,EAAAA,KAAI4H,EAAWa,OAAOC,OAAO,GAAIR,EAAO,CAC3C3I,SAAUrB,IAAuB8B,EAAAA,EAAAA,KAAIX,EAAM,CACvCnB,MAAOA,EACPqB,SAAUA,QAahByJ,GAAwBC,EAAAA,EAAAA,MAAKF,GAE7BG,EAAc,EAAEhL,MAAOA,EAAOqB,SAAUA,MAC1C,MAAO4B,EAAIf,IAAO+H,EAAAA,EAAAA,YAClB,OAAO1J,EAAAA,EAAAA,YAAW,KACd,GAAI0C,GAAMjD,EAAO,CACb,IAAIiL,EAAa,EACjB,OAAOjI,EAAQC,GAAK,EAAEwD,aAAcA,MAChCzG,EAAMuF,wBAAwBkB,EAAewE,GAAaA,EAAaxE,KACtE,KACDtD,EAAUF,GAAKjD,EAAMuF,yBAAyB0F,OAGtD,CAAEhI,EAAIjD,KAAwBkL,EAAAA,EAAAA,cAAa7J,EAAU,CACrDa,IAAKA,KAIPiJ,GAA2BJ,EAAAA,EAAAA,OAAM,EAAEK,QAASA,MAA2BtJ,EAAAA,EAAAA,KAAI,WAAY,CACzFT,SAAU+J,EAAQC,KAAK,EAAEC,QAASA,EAASC,WAAYA,EAAYC,OAAQA,EAAQC,MAAOA,MAAyB3J,EAAAA,EAAAA,KAAI,MAAO,CAC1HE,MAAO,CACHyJ,MAAOA,EACPF,WAAYA,EACZC,OAAQA,IAEbF,SA6CDI,EAAY,CAAE,UAAW,aAAc,cAAe,YAAa,MAAO,oBAAqB,qBAAsB,OAAQ,WAAY,aAEzIC,EAAQvK,IACV,IAAKgK,QAASA,EAASQ,WAAYA,EAAYC,YAAaA,EAAaC,UAAWA,EAAWC,IAAKA,EAAKC,kBAAmBA,EAAmBC,mBAAoBA,EAAoBC,KAAMA,EAAMC,SAAUA,EAAUpK,UAAWA,GAAaX,EAAM4I,GAAQxI,EAAAA,EAAAA,GAA8BJ,EAAMsK,GAEjS,OAAO5J,EAAAA,EAAAA,KAAI4H,EAAWa,OAAOC,OAAO,CAChCzI,UAAWM,EARC,WAQeN,IAC5BiI,EAAO,CACN3I,SAAUrB,IAAuBsK,EAAAA,EAAAA,MAAK,QAAS,CAC3CvI,UAXoC,WAYpCV,SAAU,EAAgBS,EAAAA,EAAAA,KAAIqJ,EAAY,CACtCC,QAASA,IACTe,EAAW,MAAqBrK,EAAAA,EAAAA,KAAIkJ,EAAa,CACjDhL,MAAOA,EACPqB,UAAwBS,EAAAA,EAAAA,KAAI,QAAS,CACjCT,UAAwBS,EAAAA,EAAAA,KAAI,KAAM,CAC9BT,SAAU2K,EAAkBZ,UAGtBtJ,EAAAA,EAAAA,KAAI,QAAS,CAC3BT,UAAwBS,EAAAA,EAAAA,KAAIX,EAAM,CAC9BnB,MAAOA,EACPsB,OAAQ,KACR8J,QAASA,EACTQ,WAAYA,EACZC,YAAaA,EACbE,IAAKA,EACLG,KAAMA,EACN7K,SAAUyK,MAEdG,GAAmCnK,EAAAA,EAAAA,KAAIkJ,EAAa,CACpDhL,MAAOA,EACPqB,UAAwBS,EAAAA,EAAAA,KAAI,QAAS,CACjCT,SAAU4K,EAAmBb,OAEhC,YA+BbO,EAAMS,aAAe,CACrBD,UAAU,EACVL,UAvFc,CAACvD,EAAO8D,KAA2BvK,EAAAA,EAAAA,KAAIuK,EAASN,IAAKxB,OAAOC,OAAO,CACjFjC,MAAOA,GACR8D,GAAW9D,GAsFVwD,IA5GW,EAAExD,MAAOA,EAAO6C,QAASA,EAASQ,WAAYA,EAAYC,YAAaA,EAAaK,KAAMA,MACrG,MAAMI,EAAUV,EAAWrD,GAE3B,OAAOzG,EAAAA,EAAAA,KAAI,KAAMyI,OAAOC,OAAO,GAAIqB,GAAeA,EAAYS,EAAS/D,GAAQ,CAC3ElH,SAAUiL,EAAUlB,EAAQC,KAAKkB,IAC7B,MAAMC,EAAYD,EAAOL,MAAQA,EAEjC,OAAOpK,EAAAA,EAAAA,KAAI,KAAM,CACbT,UAAwBS,EAAAA,EAAAA,KAAI0K,EAAW,CACnCF,QAASA,EACTC,OAAQA,KAEbA,EAAOjB,aACMxJ,EAAAA,EAAAA,KAAI,KAAM,CAC1B2K,QAASrB,EAAQpH,OACjB3C,SAAU,UA8FlB2K,kBArFsBZ,GAAWA,EAAQC,KAAKkB,IAAwBzK,EAAAA,EAAAA,KAAI,KAAM,CAChFE,MAAO,CACH0K,SAAUH,EAAOG,UAErBrL,SAAUkL,EAAOI,OAClBJ,EAAOjB,WAiFNY,KA/ES,EAAEI,QAASA,EAASC,OAAQA,MACrC,MAAOK,OAAQA,EAAQtB,QAASA,EAASuB,OAAQA,GAAUN,EACrDO,EAAWR,EAAQhB,GACzB,YAAO,IAAWwB,EAAW,IAAMF,EAASA,EAAOE,EAAUR,GAAWO,EAASA,EAAOC,GAAYA,IA+ExG,MAAMvE,GAAsBwC,EAAAA,EAAAA,MAAKY","sources":["webpack://website/../af-virtual-scroll/lib/index.esm.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\n\nimport { useReducer, useRef, useEffect, useState, useImperativeHandle, useCallback, memo, cloneElement } from \"react\";\n\nimport PropTypes from \"prop-types\";\n\nimport { jsx, jsxs } from \"react/jsx-runtime\";\n\nconst increment = x => x + 1;\n\nconst useSubscription$1 = (model, callBack, events) => {\n    const prevRenderRef = useRef(null);\n    const forceUpdate = useReducer(increment, 0)[1];\n    return useEffect((() => (model.on(forceUpdate, ...events), () => model.off(forceUpdate, ...events))), events), \n    model.inBatch ? \n    /*\n        Somebody tried to rerender, while we were in batch.\n        On batch finish component definitely must be rerendered.\n    */\n    model.queue(forceUpdate) : prevRenderRef.current = callBack(model), prevRenderRef.current;\n};\n\nconst css$3_spacer = \"VXMoQIx\";\n\nconst _excluded$3 = [ \"model\", \"children\", \"Spacer\" ];\n\nconst Events$1 = [ 0, 1 ];\n\nconst spacerKey = Date.now().toString(36);\n\nconst Rows = _ref => {\n    let {model: model, children: children, Spacer: Spacer = \"div\"} = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);\n    return useSubscription$1(model, (({startIndex: startIndex, endIndex: endIndex, virtualTopOffset: virtualTopOffset, setSpacerNode: setSpacerNode}) => {\n        const result = [ /*#__PURE__*/ jsx(Spacer, {\n            className: css$3_spacer,\n            \"aria-hidden\": \"true\",\n            style: {\n                height: virtualTopOffset\n            },\n            ref: setSpacerNode\n        }, spacerKey) ];\n        for (let i = startIndex; i < endIndex; i++) result.push(children(i, rest));\n        return result;\n    }), Events$1);\n};\n\nconst cx = (baseClass, extraClass) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\n\nconst callBacks = new Map;\n\nconst R = new ResizeObserver((entries => {\n    for (const {target: target} of entries) {\n        const cb = callBacks.get(target);\n        cb && cb(target);\n    }\n}));\n\nconst observe = (el, callBack) => {\n    callBacks.set(el, callBack), R.observe(el);\n};\n\nconst unobserve = el => callBacks.delete(el) && R.unobserve(el);\n\nconst css$2_wrapper = \"gA3QcBA\";\n\nconst Events = [ 3, 4 ];\n\nconst HeightProvider = ({model: model}) => useSubscription$1(model, (API => /*#__PURE__*/ jsx(\"div\", {\n    \"aria-hidden\": \"true\",\n    className: css$2_wrapper,\n    style: {\n        height: API.widgetScrollHeight + API.extraStickyHeight\n    }\n})), Events);\n\nconst throttle$1 = (fn, ms, ctx) => {\n    let timer = 0;\n    const invoke = () => {\n        timer = 0, fn.call(ctx);\n    };\n    const throttled = () => {\n        0 === timer && (timer = setTimeout(invoke, ms));\n    };\n    return throttled.cancel = () => {\n        clearTimeout(timer), timer = 0;\n    }, throttled;\n};\n\nclass ListBase extends class {\n    constructor() {\n        this._E = Array.from({\n            length: 7\n        }, (() => [])), this._Q = new Set, this.inBatch = 0;\n    }\n    _on(callBack, events, shouldPrepend) {\n        for (const evt of events) this._E[evt].splice(shouldPrepend ? 0 : 2147483647, 0, callBack);\n        return this;\n    }\n    on(callBack, ...events) {\n        return this._on(callBack, events, !1);\n    }\n    prependListener(callBack, ...events) {\n        return this._on(callBack, events, !0);\n    }\n    destructor() {\n        for (const events of this._E) events.splice(0);\n        this._Q.clear();\n    }\n    off(callBack, ...events) {\n        for (const evt of events) this._E[evt].splice(this._E[evt].indexOf(callBack) >>> 0, 1);\n        return this;\n    }\n    queue(cb) {\n        \"production\" !== process.env.NODE_ENV && (this.inBatch || console.error(\"trying to add event to batch queue, while inBatch is 0\")), \n        this._Q.add(cb);\n    }\n    emit(evt) {\n        if (this.inBatch) for (const cb of this._E[evt]) this._Q.add(cb); else for (const cb of this._E[evt]) cb.call(this);\n        return this;\n    }\n    /* inspired by mobx */    startBatch() {\n        return this.inBatch++, this;\n    }\n    endBatch() {\n        if (!--this.inBatch) {\n            for (const cb of this._Q) cb.call(this);\n            this._Q.clear();\n        }\n        return this;\n    }\n} {\n    /* Provided from renderer */\n    /* must be >= 1 */\n    /* sticky elements ( for example table header/footer ) must influence ONLY on widgetScrollHeight */\n    setScrollContainerNode(node) {\n        this.scrollContainerNode = node || null;\n    }\n    /* will ne used as callback, so => */    setScrollTop(v) {\n        v !== this.scrollTop && (this.scrollTop = v, this.updateVisibleRange());\n    }\n    updateExtraStickyHeight(delta) {\n        delta && (this.extraStickyHeight += delta, this.emit(4));\n    }\n    updateEndIndex() {\n        const endIndex = Math.min(this.getIndex(this.scrollTop + this.widgetHeight) + this.overscanRowsCount, this.rowsQuantity);\n        return endIndex !== this.endIndex && (this.endIndex = endIndex, this.emit(1)), this;\n    }\n    updateVisibleRange() {\n        this.startBatch();\n        const startIndex = Math.max(0, this.getIndex(this.scrollTop) - this.overscanRowsCount);\n        return startIndex !== this.startIndex && (this.startIndex = startIndex, this.virtualTopOffset = this.getOffset(startIndex), \n        this.emit(0)), this.updateEndIndex().endBatch();\n    }\n    /* must be called when row height/heights change */    remeasure() {\n        return this.startBatch().updateWidgetScrollHeight().updateVisibleRange().endBatch();\n    }\n    constructor() {\n        super(), this.scrollTop = 0, this.rowsQuantity = 0, this.overscanRowsCount = 2, \n        this.widgetHeight = 0, this.widgetWidth = 0, this.extraStickyHeight = 0, this.estimatedRowHeight = 0, \n        this.spacerNode = null, this.scrollContainerNode = null, this.setSpacerNode = node => {\n            this.spacerNode = node;\n        }, this.updateWidgetDimensions = ({offsetHeight: offsetHeight, offsetWidth: offsetWidth}) => {\n            this.startBatch(), offsetHeight !== this.widgetHeight && (this.widgetHeight = offsetHeight, \n            this.emit(5)), offsetWidth !== this.widgetWidth && (this.widgetWidth = offsetWidth, \n            this.emit(6)), this.endBatch();\n        }, this.measureRowsThrottled = throttle$1(this.measureRows, 200, this), this.startIndex = 0, \n        this.endIndex = 0, this.virtualTopOffset = 0, this.widgetScrollHeight = 0, this.on(this.measureRowsThrottled, 2, 5, 6).on(this.updateWidgetScrollHeight, 2).on(this.updateEndIndex, 2, 5);\n    }\n    destructor() {\n        this.measureRowsThrottled.cancel(), super.destructor();\n    }\n    scrollToRow(rowIndex) {\n        this.scrollContainerNode ? this.scrollContainerNode.scrollTop = this.getOffset(rowIndex) : \"production\" !== process.env.NODE_ENV && console.error(\"scrollContainerNode is not set\");\n    }\n    updateWidgetScrollHeight() {\n        const v = this.getOffset(this.rowsQuantity);\n        return v !== this.widgetScrollHeight && (this.widgetScrollHeight = v, this.emit(3)), \n        this;\n    }\n    setParams(estimatedRowHeight, overscanRowsCount, rowsQuantity) {\n        this.estimatedRowHeight = estimatedRowHeight, this.startBatch(), overscanRowsCount !== this.overscanRowsCount && (this.overscanRowsCount = overscanRowsCount, \n        this.queue(this.updateVisibleRange)), rowsQuantity !== this.rowsQuantity && (this.rowsQuantity = rowsQuantity, \n        this.emit(2)), this.endBatch();\n    }\n    /* Calculated inside model */}\n\nconst VariableHeightsModel = class extends ListBase {\n    /*\n      most significant bit of this.rowsQuantity;\n      caching it to avoid Math.clz32 calculations on every getIndex call\n  */\n    constructor() {\n        super(), this.rowHeights = [], this.fTree = [], this.msb = 0, this\n        /* must be done before events, attached in ListBase */ .prependListener(this.grow, 2).on(this.measureRowsThrottled, 0, 1);\n    }\n    grow() {\n        const {rowsQuantity: rowsQuantity} = this;\n        if (rowsQuantity < 0 || rowsQuantity > 2147483647) throw new Error(`Wrong rowsQuantity: ${rowsQuantity}. Must be 0...2_147_483_647.`);\n        this.msb = rowsQuantity && 1 << 31 - Math.clz32(rowsQuantity);\n        const curRowHeighsLength = this.rowHeights.length;\n        if (rowsQuantity > curRowHeighsLength) {\n            const oldRowHeights = this.rowHeights;\n            this.rowHeights = new Uint32Array(rowsQuantity), this.fTree = new Uint32Array(rowsQuantity + 1), \n            this.rowHeights.set(oldRowHeights), this.rowHeights.fill(this.estimatedRowHeight, curRowHeighsLength), \n            /* \n          Creating fenwick tree from an array in linear time;\n          It is much more efficient, than calling updateRowHeight N times.\n      */\n            this.fTree.set(this.rowHeights, 1);\n            for (let j, i = 1; i <= rowsQuantity; i++) j = i + (i & -i), j <= rowsQuantity && (this.fTree[j] += this.fTree[i]);\n            this.remeasure();\n        }\n    }\n    getIndex(offset) {\n        let index = 0;\n        for (let tempIndex, bitMask = this.msb; 0 !== bitMask; bitMask >>= 1) if (tempIndex = index + bitMask, \n        !(tempIndex > this.rowsQuantity)) {\n            if (offset === this.fTree[tempIndex]) return tempIndex;\n            offset > this.fTree[tempIndex] && (offset -= this.fTree[tempIndex], index = tempIndex);\n        }\n        return index;\n    }\n    getOffset(index) {\n        if (\"production\" !== process.env.NODE_ENV && index > this.rowsQuantity) throw new Error(\"index must not be > rowsQuantity\");\n        let result = 0;\n        for (;index > 0; index -= index & -index) result += this.fTree[index];\n        return result;\n    }\n    /* i starts from 1 here; */    updateRowHeight(i, delta, limitTreeLiftingIndex) {\n        for (;i < limitTreeLiftingIndex; i += i & -i) this.fTree[i] += delta;\n    }\n    measureRows() {\n        var _this$spacerNode;\n        let child = null == (_this$spacerNode = this.spacerNode) ? void 0 : _this$spacerNode.nextElementSibling;\n        if (child) {\n            let diff, index = this.startIndex, buff = 0;\n            /* We can batch-update fenwick tree, if we know, that all indexes are updated in +1 - order. */            const lim = Math.min(this.fTree.length, 1 << 32 - Math.clz32(this.endIndex - 1));\n            do {\n                diff = child.offsetHeight - this.rowHeights[index], diff && (this.rowHeights[index] += diff, \n                buff += diff, this.updateRowHeight(index + 1, diff, lim));\n            } while (++index < this.endIndex && (child = child.nextElementSibling));\n            buff && (this.updateRowHeight(lim, buff, this.fTree.length), this.remeasure());\n        }\n    }\n};\n\nconst FixedHeightsModel = class extends ListBase {\n    constructor(...args) {\n        super(...args), this.rowHeight = 0;\n    }\n    setRowHeight(v) {\n        v !== this.rowHeight && (this.rowHeight = v, this.remeasure());\n    }\n    getIndex(offset) {\n        /* rounding via bitwise hacks like |0 may not work here, because number may be > max(int32) */\n        return this.rowHeight && Math.trunc(offset / this.rowHeight);\n    }\n    getOffset(index) {\n        return index * this.rowHeight;\n    }\n    measureRows() {\n        if (this.rowsQuantity) {\n            var _this$spacerNode;\n            const tgtEl = null == (_this$spacerNode = this.spacerNode) ? void 0 : _this$spacerNode.nextElementSibling;\n            tgtEl && this.setRowHeight(tgtEl.offsetHeight);\n        }\n    }\n};\n\nconst css$1_wrapper = \"_5e-1cSu\";\n\nconst _excluded$2 = [ \"rowsQuantity\", \"children\", \"as\", \"fixed\", \"estimatedRowHeight\", \"overscanRowsCount\", \"dataRef\", \"onRangeEndMove\", \"className\" ];\n\nconst EMPTY_ARRAY = [];\n\nconst Container = _ref => {\n    let {rowsQuantity: rowsQuantity, children: children, as: Component = \"div\", fixed: fixed = !1, estimatedRowHeight: estimatedRowHeight = 20, overscanRowsCount: overscanRowsCount = 2, dataRef: dataRef, onRangeEndMove: onRangeEndMove, className: className} = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$2);\n    const [model] = useState((() => new (fixed ? FixedHeightsModel : VariableHeightsModel)));\n    useImperativeHandle(dataRef, (() => model), EMPTY_ARRAY);\n    const setScrollNode = useCallback((scrollNode => {\n        model.scrollContainerNode && unobserve(model.scrollContainerNode), model.setScrollContainerNode(scrollNode), \n        scrollNode && observe(scrollNode, model.updateWidgetDimensions);\n    }), EMPTY_ARRAY);\n    if (model.startBatch().setParams(estimatedRowHeight, overscanRowsCount, rowsQuantity), \n    useEffect((() => {\n        model.endBatch();\n    })), useEffect((() => {\n        if (onRangeEndMove) {\n            const evt = () => onRangeEndMove(model);\n            return evt(), model.on(evt, 2, 1), () => model.off(evt, 2, 1);\n        }\n    }), [ onRangeEndMove ]), useEffect((() => () => model.destructor()), EMPTY_ARRAY), \n    \"production\" !== process.env.NODE_ENV) {\n        model instanceof (fixed ? FixedHeightsModel : VariableHeightsModel) || console.warn(\"\\n                'fixed' prop is taken into account ONLY during initial component mount.\\n                All future changes are ignored. You must decide once.\");\n    }\n    /*\n      tabIndex=\"0\" is for proper keyboard nav\n      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n  */    /*#__PURE__*/\n    return jsxs(Component, Object.assign({}, props, {\n        tabIndex: \"0\",\n        className: cx(css$1_wrapper, className),\n        ref: setScrollNode,\n        onScroll: e => model.setScrollTop(e.target.scrollTop),\n        children: [ /*#__PURE__*/ jsx(HeightProvider, {\n            model: model\n        }), children(model) ]\n    }));\n};\n\n\"production\" !== process.env.NODE_ENV && (Container.propTypes = {\n    rowsQuantity: PropTypes.number.isRequired,\n    Container: PropTypes.elementType,\n    className: PropTypes.string,\n    fixed: PropTypes.bool,\n    overscanRowsCount: PropTypes.number,\n    estimatedRowHeight: PropTypes.number,\n    onRangeEndMove: PropTypes.func\n});\n\nconst _excluded$1 = [ \"children\" ];\n\nconst List = _ref => {\n    let {children: children} = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n    /*#__PURE__*/\n    return jsx(Container, Object.assign({}, props, {\n        children: model => /*#__PURE__*/ jsx(Rows, {\n            model: model,\n            children: children\n        })\n    }));\n};\n\n\"production\" !== process.env.NODE_ENV && (List.propTypes = {\n    /**\n   * @param {number} rowIndex\n   * @returns {any} one row element child. Fragments are not supported.\n   */\n    children: PropTypes.func.isRequired\n});\n\nconst index$1 = /*#__PURE__*/ memo(List);\n\nconst ExtraHeight = ({model: model, children: children}) => {\n    const [el, ref] = useState();\n    return useEffect((() => {\n        if (el && model) {\n            let prevHeight = 0;\n            return observe(el, (({offsetHeight: offsetHeight}) => {\n                model.updateExtraStickyHeight(offsetHeight - prevHeight), prevHeight = offsetHeight;\n            })), () => {\n                unobserve(el), model.updateExtraStickyHeight(-prevHeight);\n            };\n        }\n    }), [ el, model ]), /*#__PURE__*/ cloneElement(children, {\n        ref: ref\n    });\n};\n\nconst Colgroup$1 = /*#__PURE__*/ memo((({columns: columns}) => /*#__PURE__*/ jsx(\"colgroup\", {\n    children: columns.map((({dataKey: dataKey, background: background, border: border, width: width}) => /*#__PURE__*/ jsx(\"col\", {\n        style: {\n            width: width,\n            background: background,\n            border: border\n        }\n    }, dataKey)))\n})));\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/ const Row = ({index: index, columns: columns, getRowData: getRowData, getRowProps: getRowProps, Cell: Cell}) => {\n    const rowData = getRowData(index);\n    /*#__PURE__*/\n    return jsx(\"tr\", Object.assign({}, getRowProps && getRowProps(rowData, index), {\n        children: rowData ? columns.map((column => {\n            const FinalCell = column.Cell || Cell;\n            /*#__PURE__*/\n            return jsx(\"td\", {\n                children: /*#__PURE__*/ jsx(FinalCell, {\n                    rowData: rowData,\n                    column: column\n                })\n            }, column.dataKey);\n        })) : /*#__PURE__*/ jsx(\"td\", {\n            colSpan: columns.length,\n            children: \" \"\n        })\n    }));\n};\n\nconst renderRow = (index, RowProps) => /*#__PURE__*/ jsx(RowProps.Row, Object.assign({\n    index: index\n}, RowProps), index);\n\nconst renderHeaderCells = columns => columns.map((column => /*#__PURE__*/ jsx(\"th\", {\n    style: {\n        minWidth: column.minWidth\n    },\n    children: column.label\n}, column.dataKey)));\n\nconst Cell = ({rowData: rowData, column: column}) => {\n    const {render: render, dataKey: dataKey, format: format} = column;\n    const cellData = rowData[dataKey];\n    return void 0 === cellData ? \" \" : render ? render(cellData, rowData) : format ? format(cellData) : cellData;\n};\n\nconst css_wrapper = \"_2wTxqHK\", css_bodyTable = \"_1kcsJP_\";\n\nconst _excluded = [ \"columns\", \"getRowData\", \"getRowProps\", \"renderRow\", \"Row\", \"renderHeaderCells\", \"renderTfootContent\", \"Cell\", \"headless\", \"className\" ];\n\nconst Table = _ref => {\n    let {columns: columns, getRowData: getRowData, getRowProps: getRowProps, renderRow: renderRow, Row: Row, renderHeaderCells: renderHeaderCells, renderTfootContent: renderTfootContent, Cell: Cell, headless: headless, className: className} = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);\n    /*#__PURE__*/\n    return jsx(Container, Object.assign({\n        className: cx(css_wrapper, className)\n    }, props, {\n        children: model => /*#__PURE__*/ jsxs(\"table\", {\n            className: css_bodyTable,\n            children: [ /*#__PURE__*/ jsx(Colgroup$1, {\n                columns: columns\n            }), headless ? null : /*#__PURE__*/ jsx(ExtraHeight, {\n                model: model,\n                children: /*#__PURE__*/ jsx(\"thead\", {\n                    children: /*#__PURE__*/ jsx(\"tr\", {\n                        children: renderHeaderCells(columns)\n                    })\n                })\n            }), /*#__PURE__*/ jsx(\"tbody\", {\n                children: /*#__PURE__*/ jsx(Rows, {\n                    model: model,\n                    Spacer: \"tr\",\n                    columns: columns,\n                    getRowData: getRowData,\n                    getRowProps: getRowProps,\n                    Row: Row,\n                    Cell: Cell,\n                    children: renderRow\n                })\n            }), renderTfootContent ? /*#__PURE__*/ jsx(ExtraHeight, {\n                model: model,\n                children: /*#__PURE__*/ jsx(\"tfoot\", {\n                    children: renderTfootContent(columns)\n                })\n            }) : null ]\n        })\n    }));\n};\n\n\"production\" !== process.env.NODE_ENV && (Table.propTypes = {\n    className: PropTypes.string,\n    columns: PropTypes.arrayOf(PropTypes.oneOfType([ PropTypes.string, PropTypes.shape({\n        // unique key for column\n        dataKey: PropTypes.string.isRequired,\n        // for details see CellComponent implementation\n        format: PropTypes.func,\n        render: PropTypes.func,\n        formatTotal: PropTypes.func,\n        totals: PropTypes.string,\n        // column props, affecting colgroup > col tags\n        background: PropTypes.string,\n        border: PropTypes.string,\n        width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n        // works pretty shitty in col tag\n        minWidth: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n        CellComponent: PropTypes.elementType,\n        getCellExtraProps: PropTypes.func\n    }) ])).isRequired,\n    getRowData: PropTypes.func.isRequired,\n    getRowProps: PropTypes.func,\n    renderTfootContent: PropTypes.func,\n    renderHeaderCells: PropTypes.func,\n    Row: PropTypes.elementType,\n    Cell: PropTypes.elementType,\n    headless: PropTypes.bool\n}), Table.defaultProps = {\n    headless: !1,\n    renderRow: renderRow,\n    Row: Row,\n    renderHeaderCells: renderHeaderCells,\n    Cell: Cell\n};\n\nconst index = /*#__PURE__*/ memo(Table);\n\nexport { Cell, Container, ExtraHeight, index$1 as List, Row, Rows, index as Table, cx, renderHeaderCells, renderRow };\n"],"names":["increment","x","useSubscription$1","model","callBack","events","prevRenderRef","useRef","forceUpdate","useReducer","useEffect","on","off","inBatch","queue","current","_excluded$3","Events$1","spacerKey","Date","now","toString","Rows","_ref","children","Spacer","rest","_objectWithoutPropertiesLoose","startIndex","endIndex","virtualTopOffset","setSpacerNode","result","jsx","className","style","height","ref","i","push","cx","baseClass","extraClass","callBacks","Map","R","ResizeObserver","entries","target","cb","get","observe","el","set","unobserve","delete","Events","HeightProvider","API","widgetScrollHeight","extraStickyHeight","ListBase","constructor","this","_E","Array","from","length","_Q","Set","_on","shouldPrepend","evt","splice","prependListener","destructor","clear","indexOf","add","emit","call","startBatch","endBatch","setScrollContainerNode","node","scrollContainerNode","setScrollTop","v","scrollTop","updateVisibleRange","updateExtraStickyHeight","delta","updateEndIndex","Math","min","getIndex","widgetHeight","overscanRowsCount","rowsQuantity","max","getOffset","remeasure","updateWidgetScrollHeight","super","widgetWidth","estimatedRowHeight","spacerNode","updateWidgetDimensions","offsetHeight","offsetWidth","measureRowsThrottled","fn","ms","ctx","timer","invoke","throttled","setTimeout","cancel","clearTimeout","throttle$1","measureRows","scrollToRow","rowIndex","setParams","VariableHeightsModel","rowHeights","fTree","msb","grow","Error","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","fill","j","offset","index","tempIndex","bitMask","updateRowHeight","limitTreeLiftingIndex","_this$spacerNode","child","nextElementSibling","diff","buff","lim","FixedHeightsModel","args","rowHeight","setRowHeight","trunc","tgtEl","_excluded$2","EMPTY_ARRAY","Container","as","Component","fixed","dataRef","onRangeEndMove","props","useState","useImperativeHandle","setScrollNode","useCallback","scrollNode","jsxs","Object","assign","tabIndex","onScroll","e","_excluded$1","List","index$1","memo","ExtraHeight","prevHeight","cloneElement","Colgroup$1","columns","map","dataKey","background","border","width","_excluded","Table","getRowData","getRowProps","renderRow","Row","renderHeaderCells","renderTfootContent","Cell","headless","defaultProps","RowProps","rowData","column","FinalCell","colSpan","minWidth","label","render","format","cellData"],"sourceRoot":""}