{"version":3,"sources":["webpack://af-virtual-scroll/./src/models/aggregators/utils/multiGroupBy/index.js","webpack://af-virtual-scroll/./src/models/aggregators/utils/getSorter/index.js","webpack://af-virtual-scroll/./src/models/aggregators/utils/sortGroups/index.js","webpack://af-virtual-scroll/./src/models/aggregators/utils/flattenGroups/index.js","webpack://af-virtual-scroll/./src/models/aggregators/utils/getFilteredIndexes/index.js","webpack://af-virtual-scroll/./src/models/aggregators/Base/index.js","webpack://af-virtual-scroll/./src/models/aggregators/Mobx/index.js","webpack://af-virtual-scroll/./src/components/ComplexTable/style.module.scss?b8c6","webpack://af-virtual-scroll/./src/components/ComplexTable/index.js","webpack://af-virtual-scroll/./src/examples/complexTable(unstable)/basic/index.js"],"names":["indexesArray","groupDataKeysList","getRowData","priorityGroupValuesArray","lastGroupIndex","length","lastGroupDataKey","groupsMap","Map","rowIndex","row","tmpInnerObject","cellValue","innerObject","i","get","priorityValue","has","set","push","collator","Intl","Collator","undefined","numeric","sortDataKey","sortDirection","a","b","row1","row2","v1","v2","compare","sortGroups","depth","currentDepth","groupValues","values","group","sortCallback","getSorter","sort","flattenGroups","collapsedGroups","prefix","rowIndexes","idx","groupValue","subGroup","concatenated","concat","Array","isArray","apply","rowsQuantity","filtersMap","size","result","mainLoop","j","dataKey","value","toLowerCase","includes","from","v","columns","compact","groupKeys","Set","setFiltering","this","delete","toggleCompact","setSorting","setGrouping","dataKeysArray","addGrouping","clear","toggleCollapsedGroup","add","removeGrouping","indexOf","splice","merge","propertiesObj","Object","assign","stubFalse","Base","filter","col","map","find","c","priorityGroupValues","multiGroupBy","filteredIndexes","grouped","groupedSorted","getFilteredIndexes","flattenedGroups","hasGrouping","groupsSortedIndexes","noGroupsSortedIndexes","constructor","super","makeObservable","computed","visibleColumns","equals","comparer","finalIndexes","action","HeaderLabel","observer","m","label","dragRef","useDrag","type","item","ref","className","css","onClick","aria-sort","data-collapsed","HeaderInput","onChange","e","target","getCount","total","nested","getSum","SummaryCell","column","totals","sum","fn","formatTotal","format","GroupLabelDefault","groupKey","onRemove","onDoubleClick","GroupsPanel","GroupLabel","collectedProps","dropRef","useDrop","accept","drop","GroupCell","isCollapsed","groupPath","getGroupLabel","Fragment","style","marginLeft","path","reduce","res","key","ComplexTable","props","useState","RowsAggregator","useEffect","initialGroupingKeys","slice","initialGrouingIndex","initialGroupingIndex","cx","Table","renderRow","index","RowProps","realRowIndex","colSpan","Row","renderHeaderCells","minWidth","renderTfootContent","normalizedVisibleColumns","some","rows","fixedRange","firstName","faker","lastName","country","estimatedRowHeight","render","cellData","color","textAlign","lineHeight","background"],"mappings":"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","file":"e5ac5c9df9f226130f3f.js","sourcesContent":["const multiGroupBy = ( indexesArray, groupDataKeysList, getRowData, priorityGroupValuesArray ) => {\n\n    const lastGroupIndex = groupDataKeysList.length - 1;\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( lastGroupIndex < 0 ){\n            throw new Error( \"lastGroupIndex < 0\" );\n        }\n    }\n\n    const lastGroupDataKey = groupDataKeysList[ lastGroupIndex ];\n    const groupsMap = new Map();\n   \n\n    for( let rowIndex of indexesArray ){\n        /*\n            It is better to start from indexes iteration, not from groups, to minimize getRowData calls\n        */\n        const row = getRowData( rowIndex );\n\n        if( !row ){\n            continue;\n        }\n\n        let innerObject = groupsMap,\n            tmpInnerObject,\n            cellValue;\n\n        /*\n            We could put everything in one loop, but last iteration is different.\n        */\n        for( let i = 0; i < lastGroupIndex; i++ ){\n            cellValue = row[ groupDataKeysList[ i ] ];\n            tmpInnerObject = innerObject.get( cellValue );\n            if( !tmpInnerObject ){\n                tmpInnerObject = new Map();\n                for( let priorityValue of priorityGroupValuesArray[ i ] ){\n                    if( !innerObject.has( priorityValue ) ){\n                        innerObject.set( priorityValue, null );\n                    }\n                }\n                innerObject.set( cellValue, tmpInnerObject );\n            }\n            innerObject = tmpInnerObject;\n        }\n\n        cellValue = row[ lastGroupDataKey ];\n        tmpInnerObject = innerObject.get( cellValue );\n\n        if( tmpInnerObject ){\n            tmpInnerObject.push( rowIndex );\n        }\n        else {\n            for( let priorityValue of priorityGroupValuesArray[ lastGroupIndex ] ){\n                if( !innerObject.has( priorityValue  ) ){\n                    innerObject.set( priorityValue, null );\n                }\n            }\n            innerObject.set( cellValue, [ rowIndex ]);\n        }\n    }\n\n    return groupsMap;\n}\n\nexport default multiGroupBy;","const collator = new Intl.Collator( undefined, { numeric: true });\n\nconst getSorter = ( getRowData, sortDataKey, sortDirection ) => {\n\n    return ( a, b ) => {\n        const row1 = getRowData( a );\n        const row2 = getRowData( b );\n\n        if( row1 && row2 ){\n            const v1 = row1[ sortDataKey ];\n            const v2 = row2[ sortDataKey ];\n            return collator.compare( v1, v2 ) * sortDirection;\n        }\n\n        return row1 ? sortDirection : row2 ? -sortDirection : 0;\n    }\n}\n\nexport default getSorter;","import getSorter from \"../getSorter\";\n\nconst sortGroups = ( groupsMap, getRowData, sortDataKey, sortDirection, depth, currentDepth = 0 ) => {\n\n    const groupValues = groupsMap.values();\n\n    if( currentDepth < depth - 1 ){\n        for( let group of groupValues ){\n            if( group ){\n                sortGroups( group, getRowData, sortDataKey, sortDirection, depth, currentDepth + 1 );\n            }\n        }\n    }\n    else{\n        const sortCallback = getSorter( getRowData, sortDataKey, sortDirection );\n\n        for( let group of groupValues ){\n            if( group ){\n                group.sort( sortCallback );\n            }\n        }\n    }\n}\n\nexport default sortGroups;","const flattenGroups = ( groupsMap, collapsedGroups, prefix = [], groupValues = [], rowIndexes = [] ) => {\n    let idx;\n    for( let [ groupValue, subGroup ] of groupsMap ){\n        if( subGroup ){\n            const concatenated = prefix.concat( groupValue );\n            idx = -groupValues.push( concatenated );\n            rowIndexes.push( idx );\n            if( !collapsedGroups.has( idx ) ){\n                if( Array.isArray( subGroup ) ){\n                    rowIndexes.push.apply( rowIndexes, subGroup );\n                }\n                else{\n                    flattenGroups( subGroup, collapsedGroups, concatenated, groupValues, rowIndexes );\n                }\n            }\n        }\n    }\n\n    return { groupValues, rowIndexes };\n}\n\nexport default flattenGroups;","const getFilteredIndexes = ( rowsQuantity, getRowData, filtersMap ) => {\n    if( filtersMap.size ){\n\n        const result = [];\n\n        mainLoop:\n        for( let j = 0, row; j < rowsQuantity; j++ ){\n            row = getRowData( j );\n\n            if( row ){\n                for( const [ dataKey, value ] of filtersMap ){\n                    if( !( \"\" + row[ dataKey ] ).toLowerCase().includes( value ) ){\n                        continue mainLoop;\n                    }\n                }\n\n                result.push( j );\n            }            \n        }\n\n        return result;\n    }\n\n    return Array.from({ length: rowsQuantity }, ( v, i ) => i );\n}\n\nexport default getFilteredIndexes;","class Base {\n\n    /* Provided from renderer */\n    rowsQuantity = 0;\n    getRowData = null;\n    columns = [];\n    compact = true;\n\n    /* Calculated inside model */\n    filtersMap = new Map();\n    groupKeys = [];\n    sortDataKey = \"\";\n    sortDirection = -1;\n\n    collapsedGroups = new Set();\n\n    setFiltering( dataKey, value ){\n        if( value ){\n            this.filtersMap.set( dataKey, value.toLowerCase() );\n        }\n        else{\n            this.filtersMap.delete( dataKey );\n        }\n    }\n\n    toggleCompact(){\n        this.compact = !this.compact;\n    }\n\n    setSorting( dataKey ){\n        if( this.sortDataKey === dataKey ){\n            this.sortDirection *= -1;\n        }\n        this.sortDataKey = dataKey;\n    }\n\n    setGrouping( dataKeysArray ){\n        this.groupKeys = dataKeysArray;\n    }\n\n    addGrouping( dataKey ){\n        if( !this.groupKeys.includes( dataKey ) ){\n            this.groupKeys.push( dataKey );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    toggleCollapsedGroup( idx ){\n        if( this.collapsedGroups.has( idx ) ){\n            this.collapsedGroups.delete( idx );\n        }\n        else{\n            this.collapsedGroups.add( idx );\n        }\n    }\n\n    removeGrouping( dataKey ){\n        const idx = this.groupKeys.indexOf( dataKey );\n        if( idx !== -1 ){\n            this.groupKeys.splice( idx, 1 );\n            this.collapsedGroups.clear();\n        }\n    }\n\n    merge( propertiesObj ){\n        Object.assign( this, propertiesObj );\n    }\n}\n\nexport default Base;","import { makeObservable, action, comparer, computed } from \"mobx\"; \nimport multiGroupBy from \"../utils/multiGroupBy\";\nimport sortGroups from \"../utils/sortGroups\";\nimport flattenGroups from \"../utils/flattenGroups\";\nimport getSorter from \"../utils/getSorter\";\nimport getFilteredIndexes from \"../utils/getFilteredIndexes\";\nimport Base from \"../Base\";\n\nconst stubFalse = () => false;\n\nclass Mobx extends Base {\n\n    get visibleColumns(){\n        return this.columns.filter( col => !this.groupKeys.includes( col.dataKey ) );\n    }\n\n    get priorityGroupValuesArray(){\n        return this.groupKeys.map( dataKey => this.columns.find( c => c.dataKey === dataKey ).priorityGroupValues || [] );\n    }\n\n    get grouped(){\n        return multiGroupBy( this.filteredIndexes, this.groupKeys, this.getRowData, this.priorityGroupValuesArray );\n    }\n\n    get groupedSorted(){\n        if( this.sortDataKey ){\n            sortGroups( this.grouped, this.getRowData, this.sortDataKey, this.sortDirection, this.groupKeys.length );\n        }\n        return this.grouped;\n    }\n\n    get flattenedGroups(){\n        return flattenGroups( this.groupedSorted, this.collapsedGroups );\n    }\n\n    get filteredIndexes(){\n        return getFilteredIndexes( this.rowsQuantity, this.getRowData, this.filtersMap );\n    }\n\n    get noGroupsSortedIndexes(){\n        return this.sortDataKey ? this.filteredIndexes.sort( getSorter( this.getRowData, this.sortDataKey, this.sortDirection ) ) : this.filteredIndexes;\n    }\n\n    get groupsSortedIndexes(){\n        return this.flattenedGroups.rowIndexes;\n    }\n\n    get hasGrouping(){\n        return !!this.groupKeys.length;\n    }\n\n    get finalIndexes(){\n        return this.hasGrouping ? this.groupsSortedIndexes : this.noGroupsSortedIndexes;\n    }\n\n    constructor(){\n        super();\n\n        makeObservable( this, {\n            grouped: computed,\n            flattenedGroups: computed,\n            filteredIndexes: computed,\n            hasGrouping: computed,\n            \n            visibleColumns: computed({ equals: comparer.structural }),\n            priorityGroupValuesArray: computed({ equals: comparer.structural }),\n            \n            finalIndexes: computed({ equals: stubFalse }),\n            noGroupsSortedIndexes: computed({ equals: stubFalse }),\n            groupedSorted: computed({ equals: stubFalse }),\n\n            rowsQuantity: true,\n            getRowData: true,\n            columns: true,\n            compact: true,\n            filtersMap: true,\n            groupKeys: true,\n            sortDataKey: true,\n            sortDirection: true,\n            collapsedGroups: true,\n        \n            setFiltering: action,\n            toggleCompact: action,\n            setSorting: action,\n            setGrouping: action,\n            addGrouping: action,\n            toggleCollapsedGroup: action,\n            removeGrouping: action,\n            merge: action,\n        });\n    }\n}\n\nexport default Mobx;","// extracted by mini-css-extract-plugin\nexport default {\"wrapper\":\"_2B3KY_2EhDdLzl3od9PxI3\",\"noUserSelect\":\"_2S2SLB_JTzTB3lBY1T4ZW1\",\"sortableHeader\":\"_3xhCMieeqyydLLrsB_Rjwr _2S2SLB_JTzTB3lBY1T4ZW1\",\"input\":\"_7PdTV3zpJzO5l3JPCJbaz\",\"groupsPanel\":\"_24CQvBWd2KIxalcwIBcG6S\",\"groupLabel\":\"_1Pfh0g4BE_cuNHu46ByRkY _2S2SLB_JTzTB3lBY1T4ZW1\",\"compactToggler\":\"_3KQQrpclW23r77-lYRKeHq _2S2SLB_JTzTB3lBY1T4ZW1\",\"groupToggler\":\"_2t1GlnfqduCsfI_X7Q0BSx _2S2SLB_JTzTB3lBY1T4ZW1\",\"columnSummaries\":\"QsUrLMXUKybinaPXO0z0B\"};","import { Fragment, useState, useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport RowsAggregator from \"models/aggregators/Mobx\";\nimport Table from \"../Table\";\nimport cx from \"utils/cx\";\nimport css from \"./style.module.scss\";\nimport { useDrag, useDrop } from \"react-dnd\";\n\nconst HEADER_DND_TYPE = \"h\";\n\nconst HeaderLabel = /*#__PURE__*/ observer(({ m, dataKey, label, i }) => {\n\n    const [ , dragRef ] = useDrag(() => ({\n        type: HEADER_DND_TYPE,\n        item: {\n            dataKey\n        }}\n    ), [ dataKey ]);\n\n    return (\n        <div\n            ref={dragRef}\n            className={css.sortableHeader}\n            onClick={() => m.setSorting( dataKey )}\n            aria-sort={m.sortDataKey === dataKey?(m.sortDirection===1?\"ascending\":\"descending\"):undefined}\n        >\n            {i === 0 ? <span data-collapsed={m.compact?\"\":undefined} onClick={() => m.toggleCompact()} className={css.compactToggler} /> : null}\n            {label}\n        </div>\n    );\n});\n\nconst HeaderInput = /*#__PURE__*/ observer(({ m, dataKey }) => m.compact ? null : (\n    <input\n        className={css.input}\n        value={m.filtersMap.get( dataKey )||\"\"}\n        onChange={e => m.setFiltering( dataKey, e.target.value )}\n    />\n));\n\nconst getCount = rowIndexes => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        total += rowIndexes.length;\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            if( nested ){\n                total += getCount( nested );\n            }\n        }\n    }\n\n    return total;\n}\n\nconst getSum = ( rowIndexes, dataKey, getRowData ) => {\n\n    let total = 0;\n\n    if( Array.isArray( rowIndexes ) ){\n        let row;\n        for( let j of rowIndexes ){\n            row = getRowData( j );\n            if( row ){\n                total += row[ dataKey ];\n            }\n        }\n    }\n    else {\n        for( let nested of rowIndexes.values() ){\n            if( nested ){\n                total += getSum( nested, dataKey, getRowData );\n            }\n        }\n    }\n\n    return total;\n}\n\nconst SummaryCell = /*#__PURE__*/ observer(({ m, column, rowIndexes }) => {\n\n    if( column.totals === \"count\" ){\n        return getCount( rowIndexes );\n    }\n\n    if( column.totals === \"sum\" ){\n        const sum = getSum( rowIndexes, column.dataKey, m.getRowData );\n        const fn = column.formatTotal || column.format;\n        return fn ? fn( sum ) : sum;\n    }\n\n    return null;\n});\n\nconst GroupLabelDefault = ({ groupKey, columns, onRemove }) => (\n    <div className={css.groupLabel} onDoubleClick={onRemove}>\n        {columns.find( col => col.dataKey === groupKey ).label}\n    </div>\n);\n\nconst GroupsPanel = /*#__PURE__*/ observer(({ m, GroupLabel }) => {\n\n    const [ collectedProps, dropRef ] = useDrop(() => ({\n        accept: HEADER_DND_TYPE,\n        drop( item ){\n            m.addGrouping( item.dataKey );\n        }\n    }), [ m ]);\n\n    return m.compact ? null : (\n        <div className={css.groupsPanel} ref={dropRef}>\n            {m.groupKeys.length ? m.groupKeys.map( groupKey => (\n                <GroupLabel\n                    key={groupKey}\n                    groupKey={groupKey}\n                    columns={m.columns}\n                    onRemove={() => m.removeGrouping( groupKey )}\n                />\n            )) : \"Drag column headers here to group by column\" }\n        </div>\n    );\n});\n\nconst getInMap = ( map, path ) => path.reduce(( res, key ) => res.get( key ), map );\n\nconst GroupCell = /*#__PURE__*/ observer(({ m, columns, idx }) => {\n\n    const isCollapsed = m.collapsedGroups.has( idx );\n\n    if( m.hasGrouping ){\n\n        const groupPath = m.flattenedGroups.groupValues[~idx];\n\n        if( groupPath ){\n\n            const lastGroupIndex = groupPath.length - 1;\n            const groupKey = m.groupKeys[lastGroupIndex];\n            /* hidden columns also must be included */\n            const { getGroupLabel, label, format } = m.columns.find( c => c.dataKey === groupKey );\n            const groupValue = groupPath[lastGroupIndex];\n\n            return (\n                <Fragment>\n                    <span\n                        className={css.groupToggler}\n                        onClick={() => m.toggleCollapsedGroup( idx )}\n                        data-collapsed={isCollapsed?\"\":undefined}\n                        style={{\n                            marginLeft: `${(lastGroupIndex)*2}em`\n                        }}\n                    />\n                    &nbsp;\n                    {getGroupLabel?getGroupLabel(groupValue):(\n                        <Fragment>\n                            {label}:&nbsp;{format?format(groupValue):\"\"+groupValue}\n                        </Fragment>\n                    )}\n                    {columns.length ? (\n                        <span className={css.columnSummaries}>\n                            {columns.map( col => col.totals ? (\n                                <span key={col.dataKey}>\n                                    {col.label}:\n                                    &nbsp;\n                                    <SummaryCell\n                                        m={m}\n                                        column={col}\n                                        rowIndexes={getInMap(m.grouped,groupPath)}\n                                    />\n                                </span>\n                            ) : null)}\n                        </span>\n                    ) : null}\n                </Fragment>\n            );\n        }\n        \n    }\n\n    return null;\n});\n\nconst ComplexTable = ({ rowsQuantity, getRowData, className, columns, GroupLabel = GroupLabelDefault, ...props }) => {\n\n    const [ m ] = useState(() => new RowsAggregator());\n\n    /* hack to change renderRow by link */\n    const { finalIndexes } = m;\n\n    const renderRow = ( index, RowProps ) => {\n\n        const realRowIndex = finalIndexes[ index ];\n\n        return realRowIndex < 0 ? (\n            <tr key={index}>\n                <td colSpan={RowProps.columns.length}>\n                    <GroupCell m={m} idx={realRowIndex} columns={RowProps.columns} />\n                </td>\n            </tr>\n        ) : (\n            <RowProps.Row\n                {...RowProps}\n                key={index}\n                index={realRowIndex}\n            />\n        );\n    }\n\n    const renderHeaderCells = columns => columns.map(({ dataKey, label, minWidth }, i ) => (\n        <th key={dataKey} style={{ minWidth }}>\n            <HeaderLabel m={m} dataKey={dataKey} label={label} i={i} />\n            <HeaderInput m={m} dataKey={dataKey} />\n        </th>\n    ));\n\n    useEffect(() => m.merge({ rowsQuantity, getRowData, columns }), [ rowsQuantity, getRowData, columns ]);\n\n    useEffect(() => {\n        const initialGroupingKeys = m.visibleColumns\n            .slice()\n            .sort(( a, b ) => ( a.initialGrouingIndex || 0 ) - ( b.initialGrouingIndex || 0 ) )\n            .filter( col => col.initialGroupingIndex )\n            .map( col => col.dataKey );\n\n        m.setGrouping( initialGroupingKeys );\n    }, []);\n\n    const renderTfootContent = normalizedVisibleColumns => normalizedVisibleColumns.some( col => !!col.totals ) ? (\n        <tr>\n            {normalizedVisibleColumns.map( col => (\n                <td key={col.dataKey}>\n                    <SummaryCell m={m} column={col} rowIndexes={m.filteredIndexes} />\n                </td>\n            ))}\n        </tr>\n    ) : null;\n\n    /*\n        Normally must be wrapped with DndProvider, but nested providers throw error.\n        Waiting for react-dnd release, which would fix this\n    */\n    return (\n        <div className={cx(css.wrapper,className)}>\n            <GroupsPanel m={m} GroupLabel={GroupLabel} />\n            <Table\n                columns={m.visibleColumns}\n                rowsQuantity={finalIndexes.length}\n                getRowData={getRowData}\n                renderRow={renderRow}\n                renderHeaderCells={renderHeaderCells}\n                renderTfootContent={renderTfootContent}\n                {...props}\n            />\n        </div>\n    );\n}\n\nexport default /*#__PURE__*/ observer( ComplexTable );","import Table from \"af-virtual-scroll/lib/ComplexTable\";\nimport faker from \"faker\";\n\nconst rows = Array.from({ length: 10000 }, (v, i) => ({\n    i,\n    fixedRange: i % 9,\n    firstName: faker.name.firstName(),\n    lastName: faker.name.lastName(),\n    country: faker.address.country()\n}));\n\n/* Math.random is not the best option, because same rowIndex should produce same height */\nconst getPureRandomLineHeight = rowIndex => 20 + ( rowIndex % 53 ) + ( rowIndex % 87 );\n\nconst ComplexTable = () => (\n    <Table\n        rowsQuantity={rows.length}\n        getRowData={i => rows[ i ]}\n        estimatedRowHeight={30}\n        columns={[\n            {\n                dataKey: \"i\",\n                label: \"i\",\n                totals: \"sum\",\n                render: cellData => (\n                    <div style={{\n                        color: \"#000\",\n                        textAlign: \"center\",\n                        lineHeight: `${getPureRandomLineHeight(cellData)}px`,\n                        background: `hsl(${cellData*11%360},60%,60%)`\n                    }}>\n                        {cellData}\n                    </div>\n                )\n            },\n            {\n                dataKey: \"fixedRange\",\n                format: v => `fr ${v}`,\n                label: \"FR\",\n                initialGroupingIndex: 1,\n                priorityGroupValues: [ 4, 7, 71, 5 ]\n            },\n            {\n                dataKey: \"firstName\",\n                label: \"first name\",\n                initialGroupingIndex: 2,\n                priorityGroupValues: [ \"Dennis\" ],\n                totals: \"count\"\n            },\n            { dataKey: \"lastName\", label: \"last name\" },\n            { dataKey: \"country\", label: \"country\" }\n        ]}\n    />\n);\n\nexport default ComplexTable;"],"sourceRoot":""}