{"version":3,"file":"e695bdc8ab6d20f945af.js","mappings":"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","sources":["webpack://website/../af-virtual-scroll/lib/index.esm.js"],"sourcesContent":["import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport { useReducer, useRef, useEffect, useState, useImperativeHandle, useCallback, memo, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport { jsx, jsxs } from 'react/jsx-runtime';\n\nconst increment = x => x + 1;\n\nconst useForceUpdate = () => useReducer(increment, 0)[1];\n\nconst useSubscription = (model, callBack, events) => {\n  const prevRenderRef = useRef(null);\n  const forceUpdate = useForceUpdate();\n  useEffect(() => {\n    model.on(forceUpdate, ...events);\n    return () => model.off(forceUpdate, ...events);\n  }, events);\n\n  if (model.inBatch) {\n    /*\n        Somebody tried to rerender, while we were in batch.\n        On batch finish component definitely must be rerendered.\n    */\n    model.queue(forceUpdate);\n  } else {\n    prevRenderRef.current = callBack(model);\n  }\n\n  return prevRenderRef.current;\n};\n\nconst useSubscription$1 = useSubscription;\n\nconst css$3 = {\"spacer\":\"VXMoQIx\"};\n\nconst _excluded$3 = [\"model\", \"children\", \"Spacer\"];\nconst Events$1 = [0, 1];\nconst spacerKey = Date.now().toString(36);\n\nconst Rows = _ref => {\n  let {\n    model,\n    children,\n    Spacer = \"div\"\n  } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);\n\n  return useSubscription$1(model, ({\n    startIndex,\n    endIndex,\n    virtualTopOffset,\n    setSpacerNode\n  }) => {\n    const result = [/*#__PURE__*/jsx(Spacer, {\n      className: css$3.wrapper,\n      \"aria-hidden\": \"true\",\n      style: {\n        height: virtualTopOffset\n      },\n      ref: setSpacerNode\n    }, spacerKey)];\n\n    for (let i = startIndex; i < endIndex; i++) {\n      result.push(children(i, rest));\n    }\n\n    return result;\n  }, Events$1);\n};\n\nconst cx = (baseClass, extraClass) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\n\nconst callBacks = new Map();\nconst R = new ResizeObserver(entries => {\n  for (const {\n    target\n  } of entries) {\n    const cb = callBacks.get(target);\n    cb && cb(target);\n  }\n});\nconst observe = (el, callBack) => {\n  callBacks.set(el, callBack);\n  R.observe(el);\n};\nconst unobserve = el => callBacks.delete(el) && R.unobserve(el);\n\nconst css$2 = {\"wrapper\":\"gA3QcBA\"};\n\nconst Events = [3, 4];\n\nconst HeightProvider = ({\n  model\n}) => useSubscription$1(model, API => /*#__PURE__*/jsx(\"div\", {\n  \"aria-hidden\": \"true\",\n  className: css$2.wrapper,\n  style: {\n    height: API.widgetScrollHeight + API.extraStickyHeight\n  }\n}), Events);\n\nclass PubSub {\n  constructor() {\n    this._E = Array.from({\n      length: 7\n    }, () => []);\n    this._Q = new Set();\n    this.inBatch = 0;\n  }\n\n  _on(callBack, events, shouldPrepend) {\n    for (const evt of events) {\n      this._E[evt].splice(shouldPrepend ? 0 : 0x7fffffff, 0, callBack);\n    }\n\n    return this;\n  }\n\n  on(callBack, ...events) {\n    return this._on(callBack, events, false);\n  }\n\n  prependListener(callBack, ...events) {\n    return this._on(callBack, events, true);\n  }\n\n  destructor() {\n    for (const events of this._E) {\n      events.splice(0);\n    }\n\n    this._Q.clear();\n  }\n\n  off(callBack, ...events) {\n    for (const evt of events) {\n      this._E[evt].splice(this._E[evt].indexOf(callBack) >>> 0, 1);\n    }\n\n    return this;\n  }\n\n  queue(cb) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!this.inBatch) {\n        console.error(\"trying to add event to batch queue, while inBatch is 0\");\n      }\n    }\n\n    this._Q.add(cb);\n  }\n\n  emit(evt) {\n    if (this.inBatch) {\n      for (const cb of this._E[evt]) {\n        this._Q.add(cb);\n      }\n    } else {\n      for (const cb of this._E[evt]) {\n        cb.call(this);\n      }\n    }\n\n    return this;\n  }\n  /* inspired by mobx */\n\n\n  startBatch() {\n    this.inBatch++;\n    return this;\n  }\n\n  endBatch() {\n    if (! --this.inBatch) {\n      for (const cb of this._Q) {\n        cb.call(this);\n      }\n\n      this._Q.clear();\n    }\n\n    return this;\n  }\n\n}\n\nconst throttle = (fn, ms, ctx) => {\n  let timer = 0;\n\n  const cancel = () => {\n    clearTimeout(timer);\n    timer = 0;\n  };\n\n  const invoke = () => {\n    timer = 0;\n    fn.call(ctx);\n  };\n\n  const throttled = () => {\n    if (timer === 0) {\n      timer = setTimeout(invoke, ms);\n    }\n  };\n\n  throttled.cancel = cancel;\n  return throttled;\n};\n\nconst throttle$1 = throttle;\n\nclass ListBase extends PubSub {\n  /* Provided from renderer */\n\n  /* must be >= 1 */\n\n  /* sticky elements ( for example table header/footer ) must influence ONLY on widgetScrollHeight */\n  setScrollContainerNode(node) {\n    this.scrollContainerNode = node || null;\n  }\n  /* will ne used as callback, so => */\n\n\n  setScrollTop(v) {\n    if (v !== this.scrollTop) {\n      this.scrollTop = v;\n      this.updateVisibleRange();\n    }\n  }\n\n  updateExtraStickyHeight(delta) {\n    if (delta) {\n      this.extraStickyHeight += delta;\n      this.emit(4);\n    }\n  }\n\n  updateEndIndex() {\n    const endIndex = Math.min(this.getIndex(this.scrollTop + this.widgetHeight) + this.overscanRowsCount, this.rowsQuantity);\n\n    if (endIndex !== this.endIndex) {\n      this.endIndex = endIndex;\n      this.emit(1);\n    }\n\n    return this;\n  }\n\n  updateVisibleRange() {\n    this.startBatch();\n    const startIndex = Math.max(0, this.getIndex(this.scrollTop) - this.overscanRowsCount);\n\n    if (startIndex !== this.startIndex) {\n      this.startIndex = startIndex;\n      this.virtualTopOffset = this.getOffset(startIndex);\n      this.emit(0);\n    }\n\n    return this.updateEndIndex().endBatch();\n  }\n  /* must be called when row height/heights change */\n\n\n  remeasure() {\n    return this.startBatch().updateWidgetScrollHeight().updateVisibleRange().endBatch();\n  }\n\n  constructor() {\n    super();\n    this.scrollTop = 0;\n    this.rowsQuantity = 0;\n    this.overscanRowsCount = 2;\n    this.widgetHeight = 0;\n    this.widgetWidth = 0;\n    this.extraStickyHeight = 0;\n    this.estimatedRowHeight = 0;\n    this.spacerNode = null;\n    this.scrollContainerNode = null;\n\n    this.setSpacerNode = node => {\n      this.spacerNode = node;\n    };\n\n    this.updateWidgetDimensions = ({\n      offsetHeight,\n      offsetWidth\n    }) => {\n      this.startBatch();\n\n      if (offsetHeight !== this.widgetHeight) {\n        this.widgetHeight = offsetHeight;\n        this.emit(5);\n      }\n\n      if (offsetWidth !== this.widgetWidth) {\n        this.widgetWidth = offsetWidth;\n        this.emit(6);\n      }\n\n      this.endBatch();\n    };\n\n    this.measureRowsThrottled = throttle$1(this.measureRows, 200, this);\n    this.startIndex = 0;\n    this.endIndex = 0;\n    this.virtualTopOffset = 0;\n    this.widgetScrollHeight = 0;\n    this.on(this.measureRowsThrottled, 2, 5, 6).on(this.updateWidgetScrollHeight, 2).on(this.updateEndIndex, 2, 5);\n  }\n\n  destructor() {\n    this.measureRowsThrottled.cancel();\n    super.destructor();\n  }\n\n  scrollToRow(rowIndex) {\n    if (this.scrollContainerNode) {\n      this.scrollContainerNode.scrollTop = this.getOffset(rowIndex);\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.error(\"scrollContainerNode is not set\");\n    }\n  }\n\n  updateWidgetScrollHeight() {\n    const v = this.getOffset(this.rowsQuantity);\n\n    if (v !== this.widgetScrollHeight) {\n      this.widgetScrollHeight = v;\n      this.emit(3);\n    }\n\n    return this;\n  }\n\n  setParams(estimatedRowHeight, overscanRowsCount, rowsQuantity) {\n    this.estimatedRowHeight = estimatedRowHeight;\n    this.startBatch();\n\n    if (overscanRowsCount !== this.overscanRowsCount) {\n      this.overscanRowsCount = overscanRowsCount;\n      this.queue(this.updateVisibleRange);\n    }\n\n    if (rowsQuantity !== this.rowsQuantity) {\n      this.rowsQuantity = rowsQuantity;\n      this.emit(2);\n    }\n\n    this.endBatch();\n  }\n  /* Calculated inside model */\n\n\n}\n\nclass VariableSizeList extends ListBase {\n  /*\n      most significant bit of this.rowsQuantity;\n      caching it to avoid Math.clz32 calculations on every getIndex call\n  */\n  constructor() {\n    super();\n    this.rowHeights = [];\n    this.fTree = [];\n    this.msb = 0;\n    this\n    /* must be done before events, attached in ListBase */\n    .prependListener(this.grow, 2).on(this.measureRowsThrottled, 0, 1);\n  }\n\n  grow() {\n    const {\n      rowsQuantity\n    } = this;\n\n    if (rowsQuantity < 0 || rowsQuantity > 0x7fffffff) {\n      throw new Error(`Wrong rowsQuantity: ${rowsQuantity}. Must be 0...2_147_483_647.`);\n    }\n\n    this.msb = rowsQuantity && 1 << 31 - Math.clz32(rowsQuantity);\n    const curRowHeighsLength = this.rowHeights.length;\n\n    if (rowsQuantity > curRowHeighsLength) {\n      const oldRowHeights = this.rowHeights;\n      this.rowHeights = new Uint32Array(rowsQuantity);\n      this.fTree = new Uint32Array(rowsQuantity + 1);\n      this.rowHeights.set(oldRowHeights);\n      this.rowHeights.fill(this.estimatedRowHeight, curRowHeighsLength);\n      /* \n          Creating fenwick tree from an array in linear time;\n          It is much more efficient, than calling updateRowHeight N times.\n      */\n\n      this.fTree.set(this.rowHeights, 1);\n\n      for (let i = 1, j; i <= rowsQuantity; i++) {\n        j = i + (i & -i);\n\n        if (j <= rowsQuantity) {\n          this.fTree[j] += this.fTree[i];\n        }\n      }\n\n      this.remeasure();\n    }\n  }\n\n  getIndex(offset) {\n    let index = 0;\n\n    for (let bitMask = this.msb, tempIndex; bitMask !== 0; bitMask >>= 1) {\n      tempIndex = index + bitMask;\n\n      if (tempIndex > this.rowsQuantity) {\n        continue;\n      }\n\n      if (offset === this.fTree[tempIndex]) {\n        return tempIndex;\n      }\n\n      if (offset > this.fTree[tempIndex]) {\n        offset -= this.fTree[tempIndex];\n        index = tempIndex;\n      }\n    }\n\n    return index;\n  }\n\n  getOffset(index) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (index > this.rowsQuantity) {\n        throw new Error(\"index must not be > rowsQuantity\");\n      }\n    }\n\n    let result = 0;\n\n    for (; index > 0; index -= index & -index) {\n      result += this.fTree[index];\n    }\n\n    return result;\n  }\n  /* i starts from 1 here; */\n\n\n  updateRowHeight(i, delta, limitTreeLiftingIndex) {\n    for (; i < limitTreeLiftingIndex; i += i & -i) {\n      this.fTree[i] += delta;\n    }\n  }\n\n  measureRows() {\n    var _this$spacerNode;\n\n    let child = (_this$spacerNode = this.spacerNode) == null ? void 0 : _this$spacerNode.nextElementSibling;\n\n    if (child) {\n      let index = this.startIndex,\n          diff,\n          buff = 0;\n      /* We can batch-update fenwick tree, if we know, that all indexes are updated in +1 - order. */\n\n      const lim = Math.min(this.fTree.length, 1 << 32 - Math.clz32(this.endIndex - 1));\n\n      do {\n        diff = child.offsetHeight - this.rowHeights[index];\n\n        if (diff) {\n          this.rowHeights[index] += diff;\n          buff += diff;\n          this.updateRowHeight(index + 1, diff, lim);\n        }\n      } while (++index < this.endIndex && (child = child.nextElementSibling));\n\n      if (buff) {\n        this.updateRowHeight(lim, buff, this.fTree.length);\n        this.remeasure();\n      }\n    }\n  }\n\n}\n\nconst VariableHeightsModel = VariableSizeList;\n\nclass FixedSizeList extends ListBase {\n  constructor(...args) {\n    super(...args);\n    this.rowHeight = 0;\n  }\n\n  setRowHeight(v) {\n    if (v !== this.rowHeight) {\n      this.rowHeight = v;\n      this.remeasure();\n    }\n  }\n\n  getIndex(offset) {\n    /* rounding via bitwise hacks like |0 may not work here, because number may be > max(int32) */\n    return this.rowHeight && Math.trunc(offset / this.rowHeight);\n  }\n\n  getOffset(index) {\n    return index * this.rowHeight;\n  }\n\n  measureRows() {\n    if (this.rowsQuantity) {\n      var _this$spacerNode;\n\n      const tgtEl = (_this$spacerNode = this.spacerNode) == null ? void 0 : _this$spacerNode.nextElementSibling;\n\n      if (tgtEl) {\n        this.setRowHeight(tgtEl.offsetHeight);\n      }\n    }\n  }\n\n}\n\nconst FixedHeightsModel = FixedSizeList;\n\nconst css$1 = {\"wrapper\":\"_5e-1cSu\"};\n\nconst _excluded$2 = [\"rowsQuantity\", \"children\", \"as\", \"fixed\", \"estimatedRowHeight\", \"overscanRowsCount\", \"dataRef\", \"onRangeEndMove\", \"className\"];\nconst EMPTY_ARRAY = [];\n\nconst Container = _ref => {\n  let {\n    rowsQuantity,\n    children,\n    as: Component = \"div\",\n    fixed = false,\n    estimatedRowHeight = 20,\n    overscanRowsCount = 2,\n    dataRef,\n    onRangeEndMove,\n    className\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$2);\n\n  const [model] = useState(() => new (fixed ? FixedHeightsModel : VariableHeightsModel)());\n  useImperativeHandle(dataRef, () => model, EMPTY_ARRAY);\n  const setScrollNode = useCallback(scrollNode => {\n    if (model.scrollContainerNode) {\n      unobserve(model.scrollContainerNode);\n    }\n\n    model.setScrollContainerNode(scrollNode);\n\n    if (scrollNode) {\n      observe(scrollNode, model.updateWidgetDimensions);\n    }\n  }, EMPTY_ARRAY);\n  model.startBatch().setParams(estimatedRowHeight, overscanRowsCount, rowsQuantity);\n  useEffect(() => {\n    model.endBatch();\n  });\n  useEffect(() => {\n    if (onRangeEndMove) {\n      const evt = () => onRangeEndMove(model);\n\n      evt();\n      model.on(evt, 2, 1);\n      return () => model.off(evt, 2, 1);\n    }\n  }, [onRangeEndMove]);\n  useEffect(() => () => model.destructor(), EMPTY_ARRAY);\n\n  if (process.env.NODE_ENV !== \"production\") {\n    const AssumedConstructor = fixed ? FixedHeightsModel : VariableHeightsModel;\n\n    if (!(model instanceof AssumedConstructor)) {\n      console.warn(`\n                'fixed' prop is taken into account ONLY during initial component mount.\n                All future changes are ignored. You must decide once.`);\n    }\n  }\n  /*\r\n      tabIndex=\"0\" is for proper keyboard nav\r\n      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n  */\n\n\n  return /*#__PURE__*/jsxs(Component, Object.assign({}, props, {\n    tabIndex: \"0\",\n    className: cx(css$1.wrapper, className),\n    ref: setScrollNode,\n    onScroll: e => model.setScrollTop(e.target.scrollTop),\n    children: [/*#__PURE__*/jsx(HeightProvider, {\n      model: model\n    }), children(model)]\n  }));\n};\n\nprocess.env.NODE_ENV !== \"production\" ? Container.propTypes = {\n  rowsQuantity: PropTypes.number.isRequired,\n  Container: PropTypes.elementType,\n  className: PropTypes.string,\n  fixed: PropTypes.bool,\n  overscanRowsCount: PropTypes.number,\n  estimatedRowHeight: PropTypes.number,\n  onRangeEndMove: PropTypes.func\n} : void 0;\n\nconst _excluded$1 = [\"children\"];\n\nconst List = _ref => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n\n  return /*#__PURE__*/jsx(Container, Object.assign({}, props, {\n    children: model => /*#__PURE__*/jsx(Rows, {\n      model: model,\n      children: children\n    })\n  }));\n};\n\nprocess.env.NODE_ENV !== \"production\" ? List.propTypes = {\n  /**\r\n   * @param {number} rowIndex\r\n   * @returns {any} one row element child. Fragments are not supported.\r\n   */\n  children: PropTypes.func.isRequired\n} : void 0;\nconst index$1 = /*#__PURE__*/memo(List);\n\nconst ExtraHeight = ({\n  model,\n  children\n}) => {\n  const [el, ref] = useState();\n  useEffect(() => {\n    if (el && model) {\n      let prevHeight = 0;\n      observe(el, ({\n        offsetHeight\n      }) => {\n        model.updateExtraStickyHeight(offsetHeight - prevHeight);\n        prevHeight = offsetHeight;\n      });\n      return () => {\n        unobserve(el);\n        model.updateExtraStickyHeight(-prevHeight);\n      };\n    }\n  }, [el, model]);\n  return /*#__PURE__*/cloneElement(children, {\n    ref\n  });\n};\n\nconst Colgroup = ({\n  columns\n}) => /*#__PURE__*/jsx(\"colgroup\", {\n  children: columns.map(({\n    dataKey,\n    background,\n    border,\n    width\n  }) => /*#__PURE__*/jsx(\"col\", {\n    style: {\n      width,\n      background,\n      border\n    }\n  }, dataKey))\n});\n\nconst Colgroup$1 = /*#__PURE__*/memo(Colgroup);\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\nconst Row = ({\n  index,\n  columns,\n  getRowData,\n  getRowProps,\n  Cell\n}) => {\n  const rowData = getRowData(index);\n  return /*#__PURE__*/jsx(\"tr\", Object.assign({}, getRowProps && getRowProps(rowData, index), {\n    children: rowData ? columns.map(column => {\n      const FinalCell = column.Cell || Cell;\n      return /*#__PURE__*/jsx(\"td\", {\n        children: /*#__PURE__*/jsx(FinalCell, {\n          rowData: rowData,\n          column: column\n        })\n      }, column.dataKey);\n    }) : /*#__PURE__*/jsx(\"td\", {\n      colSpan: columns.length,\n      children: DEFAULT_EMPTY_CELL_CONTENT\n    })\n  }));\n};\nconst renderRow = (index, RowProps) => /*#__PURE__*/jsx(RowProps.Row, Object.assign({\n  index: index\n}, RowProps), index);\nconst renderHeaderCells = columns => columns.map(column => /*#__PURE__*/jsx(\"th\", {\n  style: {\n    minWidth: column.minWidth\n  },\n  children: column.label\n}, column.dataKey));\nconst Cell = ({\n  rowData,\n  column\n}) => {\n  const {\n    render,\n    dataKey,\n    format\n  } = column;\n  const cellData = rowData[dataKey];\n\n  if (cellData === undefined) {\n    return DEFAULT_EMPTY_CELL_CONTENT;\n  }\n\n  if (render) {\n    return render(cellData, rowData);\n  }\n\n  if (format) {\n    return format(cellData);\n  }\n\n  return cellData;\n};\n\nconst css = {\"wrapper\":\"_2wTxqHK\",\"bodyTable\":\"_1kcsJP_\"};\n\nconst _excluded = [\"columns\", \"getRowData\", \"getRowProps\", \"renderRow\", \"Row\", \"renderHeaderCells\", \"renderTfootContent\", \"Cell\", \"headless\", \"className\"];\n\nconst Table = _ref => {\n  let {\n    columns,\n    getRowData,\n    getRowProps,\n    renderRow,\n    Row,\n    renderHeaderCells,\n    renderTfootContent,\n    Cell,\n    headless,\n    className\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return /*#__PURE__*/jsx(Container, Object.assign({\n    className: cx(css.wrapper, className)\n  }, props, {\n    children: model => /*#__PURE__*/jsxs(\"table\", {\n      className: css.bodyTable,\n      children: [/*#__PURE__*/jsx(Colgroup$1, {\n        columns: columns\n      }), headless ? null : /*#__PURE__*/jsx(ExtraHeight, {\n        model: model,\n        children: /*#__PURE__*/jsx(\"thead\", {\n          children: /*#__PURE__*/jsx(\"tr\", {\n            children: renderHeaderCells(columns)\n          })\n        })\n      }), /*#__PURE__*/jsx(\"tbody\", {\n        children: /*#__PURE__*/jsx(Rows, {\n          model: model,\n          Spacer: \"tr\",\n          columns: columns,\n          getRowData: getRowData,\n          getRowProps: getRowProps,\n          Row: Row,\n          Cell: Cell,\n          children: renderRow\n        })\n      }), renderTfootContent ? /*#__PURE__*/jsx(ExtraHeight, {\n        model: model,\n        children: /*#__PURE__*/jsx(\"tfoot\", {\n          children: renderTfootContent(columns)\n        })\n      }) : null]\n    })\n  }));\n};\n\nprocess.env.NODE_ENV !== \"production\" ? Table.propTypes = {\n  className: PropTypes.string,\n  columns: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({\n    // unique key for column\n    dataKey: PropTypes.string.isRequired,\n    // for details see CellComponent implementation\n    format: PropTypes.func,\n    render: PropTypes.func,\n    formatTotal: PropTypes.func,\n    totals: PropTypes.string,\n    // column props, affecting colgroup > col tags\n    background: PropTypes.string,\n    border: PropTypes.string,\n    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    // works pretty shitty in col tag\n    minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    CellComponent: PropTypes.elementType,\n    getCellExtraProps: PropTypes.func\n  })])).isRequired,\n  getRowData: PropTypes.func.isRequired,\n  getRowProps: PropTypes.func,\n  renderTfootContent: PropTypes.func,\n  renderHeaderCells: PropTypes.func,\n  Row: PropTypes.elementType,\n  Cell: PropTypes.elementType,\n  headless: PropTypes.bool\n} : void 0;\nTable.defaultProps = {\n  headless: false,\n  renderRow,\n  Row,\n  renderHeaderCells,\n  Cell\n};\nconst index = /*#__PURE__*/memo(Table);\n\nexport { Cell, Container, ExtraHeight, index$1 as List, Row, Rows, index as Table, cx, renderHeaderCells, renderRow };\n"],"names":["increment","x","useSubscription$1","model","callBack","events","prevRenderRef","useRef","forceUpdate","useReducer","useEffect","on","off","inBatch","queue","current","css$3","_excluded$3","Events$1","spacerKey","Date","now","toString","Rows","_ref","children","Spacer","rest","_objectWithoutPropertiesLoose","startIndex","endIndex","virtualTopOffset","setSpacerNode","result","jsx","className","wrapper","style","height","ref","i","push","cx","baseClass","extraClass","callBacks","Map","R","ResizeObserver","entries","target","cb","get","observe","el","set","unobserve","delete","css$2","Events","HeightProvider","API","widgetScrollHeight","extraStickyHeight","throttle$1","fn","ms","ctx","timer","invoke","call","throttled","setTimeout","cancel","clearTimeout","ListBase","constructor","this","_E","Array","from","length","_Q","Set","_on","shouldPrepend","evt","splice","prependListener","destructor","clear","indexOf","add","emit","startBatch","endBatch","setScrollContainerNode","node","scrollContainerNode","setScrollTop","v","scrollTop","updateVisibleRange","updateExtraStickyHeight","delta","updateEndIndex","Math","min","getIndex","widgetHeight","overscanRowsCount","rowsQuantity","max","getOffset","remeasure","updateWidgetScrollHeight","super","widgetWidth","estimatedRowHeight","spacerNode","updateWidgetDimensions","offsetHeight","offsetWidth","measureRowsThrottled","measureRows","scrollToRow","rowIndex","setParams","VariableHeightsModel","rowHeights","fTree","msb","grow","Error","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","fill","j","offset","index","tempIndex","bitMask","updateRowHeight","limitTreeLiftingIndex","_this$spacerNode","child","nextElementSibling","diff","buff","lim","FixedHeightsModel","args","rowHeight","setRowHeight","trunc","tgtEl","css$1","_excluded$2","EMPTY_ARRAY","Container","as","Component","fixed","dataRef","onRangeEndMove","props","useState","useImperativeHandle","setScrollNode","useCallback","scrollNode","jsxs","Object","assign","tabIndex","onScroll","e","_excluded$1","List","index$1","memo","ExtraHeight","prevHeight","cloneElement","Colgroup","columns","map","dataKey","background","border","width","Colgroup$1","css","_excluded","Table","getRowData","getRowProps","renderRow","Row","renderHeaderCells","renderTfootContent","Cell","headless","defaultProps","RowProps","rowData","column","FinalCell","colSpan","minWidth","label","render","format","cellData","undefined"],"sourceRoot":""}